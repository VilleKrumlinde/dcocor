            
{ Copyright (C) 2009, Serge Voloshenyuk
  
  This file is Free Software and part of DCocoR
  
  It is licensed under the following three licenses as alternatives:
    1. GNU Lesser General Public License (LGPL) V2.1 or any newer version
    2. GNU General Public License (GPL) V2 or any newer version
    3. Apache License, V2.0 or any newer version
  
  You may not use this file except in compliance with at least one of
  the above three licenses.
  
  See LICENSE.txt at the top of this package for the
  complete terms and further detail along with the license texts for
  the licenses in COPYING-LIB.txt, COPYING.txt and LICENSE-2.0.txt respectively.
} 

{ This unit was generated by DCocoR.  
  Any code in this file that you edit manually will be over-written when the file is regenerated.
}

unit DelphiUnit;

interface

uses Classes,CocoAncestor,
         SysUtils,StrUtils, DelphiCond;

type


  TDelphiUnitScanner = class(TCocoRScanner)
  public
    procedure SkipIgnoreSet; override;
    procedure ScanSym(state: Integer; var sym: Integer); override;
    function SkipComments(ind: Integer): Boolean; override;
  end;


  TDelphiUnit = class(TCocoRGrammar)
  
  protected
               
   procedure IncludeFile(const Filename: String);
 
    procedure _DelphiUnit;
    procedure _Qualident;
    procedure _PortabilityDirective;
    procedure _InterfaceBody;
    procedure _UsesClause;
    procedure _InterfaceDecl;
    procedure _QualidentList;
    procedure _ConstantDecl;
    procedure _VarDecl;
    procedure _TypeDecl;
    procedure _ExportedHeading;
    procedure _ResourceString;
    procedure _TypeId;
    procedure _GQualident;
    procedure _Type;
    procedure _ConstExprOrStructConst;
    procedure _ConstExpr;
    procedure _DotNetAttr;
    procedure _GenericDecl;
    procedure _ClassType;
    procedure _ObjectType;
    procedure _InterfaceType;
    procedure _Directive;
    procedure _IdentList;
    procedure _EnumeratedType;
    procedure _ProcedureType;
    procedure _SubrangeType;
    procedure _PointerType;
    procedure _StrucType;
    procedure _ClassRefType;
    procedure _EnumeratedTypeElement;
    procedure _ArrayType;
    procedure _SetType;
    procedure _FileType;
    procedure _RecType;
    procedure _ArrayIndexType;
    procedure _RecBody;
    procedure _FieldDecl;
    procedure _MethodHeading;
    procedure _Property;
    procedure _VariantSection;
    procedure _RecVariant;
    procedure _FieldList;
    procedure _GQualidentList;
    procedure _ClassBody;
    procedure _IMethodHeading;
    procedure _ObjFieldDecl;
    procedure _FormalParameters;
    procedure _FormalParm;
    procedure _PropertyInterface;
    procedure _PropertySpecifier;
    procedure _Expression;
    procedure _SimpleExpression;
    procedure _RelOp;
    procedure _Term;
    procedure _AddOp;
    procedure _Factor;
    procedure _MulOp;
    procedure _Number;
    procedure _SetConstructor;
    procedure _Designator;
    procedure _SetElement;
    procedure _ExprList;
    procedure _GParm;

  public
            
   InPDir,IsProc,InPropSpec,InStruct,InStructHeader: Boolean;
   PreProcessor: TDelphiCond;
   Base: String;
   function InSubRangeSet: Boolean;
   procedure CheckHomograph(var sym: Integer); override;
   procedure ProcessDelphiPragma(const str: String);
   procedure Reinit; override;
   procedure SetSourceFileName(const Filename: String); override;


    procedure ProcessPragmas; override;
    function  ErrorMessage(ErrorType,ErrorCode: Integer; const data: string): String; override;
    function  TokenToString(n: Integer): String; override;
    function  CreateScanner: TBaseScanner; override;
    function Execute: Boolean; override;

    constructor Create(AOwner: TComponent); override;

  end;

implementation

const

	identSym = 1;	numberSym = 2;	stringSym = 3;	floatSym = 4;	hexnumberSym = 5;
	_sclSym = 6;	strSym = 7;	cntrSym = 8;	destrSym = 9;	intfSym = 10;
	dintfSym = 11;	ressSym = 12;	procSym = 13;	implSym = 14;	deprSym = 15;
	plfmSym = 16;	libSym = 17;	absSym = 18;	STRICTSym = 19;	PRIVATESym = 20;
	PROTECTEDSym = 21;	PUBLICSym = 22;	PUBLISHEDSym = 23;	CDECLSym = 24;	REGISTERSym = 25;
	DYNAMICSym = 26;	VIRTUALSym = 27;	EXPORTSym = 28;	EXTERNALSym = 29;	NEARSym = 30;
	FARSym = 31;	FORWARDSym = 32;	OVERRIDESym = 33;	OVERLOADSym = 34;	PASCALSym = 35;
	REINTRODUCESym = 36;	SAFECALLSym = 37;	STDCALLSym = 38;	VARARGSSym = 39;	INLINESym = 40;
	ASSEMBLERSym = 41;	STATICSym = 42;	MESSAGESym = 43;	FINALSym = 44;	ABSTRACTSym = 45;
	HELPERSym = 46;	SEALEDSym = 47;	INDEXSym = 48;	DEFAULTSym = 49;	READSym = 50;
	WRITESym = 51;	STOREDSym = 52;	IMPLEMENTSSym = 53;	NODEFAULTSym = 54;	READONLYSym = 55;
	WRITEONLYSym = 56;	DISPIDSym = 57;	UNITSym = 58;	USESSym = 59;	CONSTSym = 60;
	VARSym = 61;	TYPESym = 62;	_colonSym = 63;	_equalSym = 64;	_lparenSym = 65;
	_commaSym = 66;	_rparenSym = 67;	_lbrackSym = 68;	_rbrackSym = 69;	TOSym = 70;
	_uparrowSym = 71;	_point_pointSym = 72;	PACKEDSym = 73;	SETSym = 74;	OFSym = 75;
	FILESym = 76;	ARRAYSym = 77;	CLASSSym = 78;	RECORDSym = 79;	FORSym = 80;
	CASESym = 81;	ENDSym = 82;	OBJECTSym = 83;	FUNCTIONSym = 84;	OUTSym = 85;
	INSym = 86;	_pointSym = 87;	PROPERTYSym = 88;	_plusSym = 89;	_minusSym = 90;
	NILSym = 91;	NOTSym = 92;	_atSym = 93;	_lessSym = 94;	_greaterSym = 95;
	_less_equalSym = 96;	_greater_equalSym = 97;	_less_greaterSym = 98;	ORSym = 99;	XORSym = 100;
	_starSym = 101;	_slashSym = 102;	DIVSym = 103;	MODSym = 104;	ANDSym = 105;
	SHLSym = 106;	SHRSym = 107;	_NOSYMB = 108;	DelphiPragmaSym = 109;	_lbraceSym = 110;
	_lparen_starSym = 111;	_slash_slashSym = 112;

var DelphiUnitSymSets: TSetArray;


var
  DelphiUnitST: TStartTable = nil;
  DelphiUnitLiterals: TStringList = nil;

{ TDelphiUnitScanner }

procedure TDelphiUnitScanner.ScanSym(state: Integer; var sym: Integer);
 var apx: TSymbolRec;
begin
 apx.Beg := -1;

 while True do
 begin
  NextCh;
  case state of
	 1:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='Z'))or(CurrInputCh='_') then
		else begin
		  sym := identSym;
		  CheckLiteral(sym);
		  Exit;
		end;
	 2:
		begin
		  EndContext(apx);
		  sym := numberSym;
		  Exit;
		end;
	 3:
		if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	 4:
		if not(((CurrInputCh>=#1)and(CurrInputCh<=#31))or(CurrInputCh='''')) then
		else if (CurrInputCh = '''') then
		  state := 3
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 5:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 6
		else if (CurrInputCh = '$') then
		  state := 7
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 6:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	 7:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		  state := 8
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 8:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		else if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	 9:
		if not(((CurrInputCh>=#1)and(CurrInputCh<=#31))or(CurrInputCh='''')) then
		else if (CurrInputCh = '''') then
		  state := 3
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	10:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 11
		else if (CurrInputCh = '$') then
		  state := 12
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	11:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	12:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		  state := 13
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	13:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		else if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	14:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = 'E') then
		  state := 15
		else begin
		  sym := floatSym;
		  Exit;
		end;
	15:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 17
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 16
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	16:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 17
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	17:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else begin
		  sym := floatSym;
		  Exit;
		end;
	18:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 20
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 19
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	19:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 20
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	20:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else begin
		  sym := floatSym;
		  Exit;
		end;
	21:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		  state := 22
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	22:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		else begin
		  sym := hexnumberSym;
		  Exit;
		end;
	23:
		begin
		  sym := _sclSym;
		  Exit;
		end;
	24:
		if not((CurrInputCh='}')) then
		else if (CurrInputCh = '}') then
		  state := 25
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	25:
		begin
		  sym := DelphiPragmaSym;
		  Exit;
		end;
	26:
		begin
		  sym := _lparen_starSym;
		  Exit;
		end;
	27:
		begin
		  sym := _slash_slashSym;
		  Exit;
		end;
	28:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '.') then
		begin   state := 30; BeginContext(apx); end
		else if (CurrInputCh = 'E') then
		  state := 18
		else begin
		  sym := numberSym;
		  Exit;
		end;
	29:
		if (CurrInputCh = '$') then
		  state := 24
		else begin
		  sym := _lbraceSym;
		  Exit;
		end;
	30:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		begin   state := 14; apx.Beg := -1; end
		else if (CurrInputCh = '.') then
		begin   state := 2; BeginContext(apx); end
		else if (CurrInputCh = 'E') then
		begin   state := 15; apx.Beg := -1; end
		else begin
		  sym := floatSym;
		  Exit;
		end;
	31:
		begin
		  sym := _colonSym;
		  Exit;
		end;
	32:
		begin
		  sym := _equalSym;
		  Exit;
		end;
	33:
		begin
		  sym := _commaSym;
		  Exit;
		end;
	34:
		begin
		  sym := _rparenSym;
		  Exit;
		end;
	35:
		begin
		  sym := _lbrackSym;
		  Exit;
		end;
	36:
		begin
		  sym := _rbrackSym;
		  Exit;
		end;
	37:
		begin
		  sym := _uparrowSym;
		  Exit;
		end;
	38:
		begin
		  sym := _point_pointSym;
		  Exit;
		end;
	39:
		begin
		  sym := _plusSym;
		  Exit;
		end;
	40:
		begin
		  sym := _minusSym;
		  Exit;
		end;
	41:
		begin
		  sym := _atSym;
		  Exit;
		end;
	42:
		begin
		  sym := _less_equalSym;
		  Exit;
		end;
	43:
		begin
		  sym := _greater_equalSym;
		  Exit;
		end;
	44:
		begin
		  sym := _less_greaterSym;
		  Exit;
		end;
	45:
		begin
		  sym := _starSym;
		  Exit;
		end;
	46:
		if (CurrInputCh = '*') then
		  state := 26
		else begin
		  sym := _lparenSym;
		  Exit;
		end;
	47:
		if (CurrInputCh = '/') then
		  state := 27
		else begin
		  sym := _slashSym;
		  Exit;
		end;
	48:
		if (CurrInputCh = '.') then
		  state := 38
		else begin
		  sym := _pointSym;
		  Exit;
		end;
	49:
		if (CurrInputCh = '=') then
		  state := 42
		else if (CurrInputCh = '>') then
		  state := 44
		else begin
		  sym := _lessSym;
		  Exit;
		end;
	50:
		if (CurrInputCh = '=') then
		  state := 43
		else begin
		  sym := _greaterSym;
		  Exit;
		end;
  
    else begin
      if CurrInputCh=#0 then
           sym := _EOFSYMB
      else sym := _NOSYMB;
      Exit;
    end;
  end;
 end;
end;


procedure TDelphiUnitScanner.SkipIgnoreSet;
begin
  while (CurrInputCh = ' ') or 
    ( (CurrInputCh=#9)or(CurrInputCh=#10)or(CurrInputCh=#13) )
  do NextCh;
end;


function TDelphiUnitScanner.SkipComments(ind: Integer): Boolean;
begin
  Result := True;
  case ind of
    _lbraceSym: SkipCommentTo('}');
    _lparen_starSym: SkipCommentTo('*)');
    _slash_slashSym: SkipCommentTo(#13);

    else Result := False;
  end;
end;



{ TDelphiUnit }

                    
 
procedure TDelphiUnit.CheckHomograph(var sym: Integer);
begin
  if ((sym=ABSTRACTSym)and not (IsProc or InStructHeader)) or
     ((sym=DISPIDSym)and not(IsProc or InPropSpec)) or
     ((sym in [deprSym..absSym])and not InPDir) or
     ((sym in [CDECLSym..FINALSym])and not IsProc) or
     ((sym in [HELPERSym,SEALEDSym])and not InStructHeader) or
     ((sym in [STRICTSym..PUBLISHEDSym])and not InStruct) or
     ((sym in [INDEXSym..WRITEONLYSym])and not InPropSpec)
  then sym := identSym;
end; 
 
procedure TDelphiUnit.SetSourceFileName(const Filename: String);
begin
  inherited;
  Base := ExtractFilePath(Filename);
end;

procedure TDelphiUnit.IncludeFile(const Filename: String);
var fn: String;
    BMark, OldSrc: String;
    WC,EC : Integer;
begin
  fn := ExpandFileName(Base+Filename);
  if FileExists(fn) then
  begin
    WC := WarnCount; EC := ErrorCount;
    BMark := Bookmark;
    OldSrc := Scanner.Source;
    try
      SetSourceFileName(fn);
      _InterfaceBody;
    finally
      Scanner.SetSource(OldSrc);
      GotoBookmark(BMark);
      WarnCount := WC; ErrorCount := EC;
    end;
  end;
end;
 
procedure TDelphiUnit.Reinit;
begin
  inherited;
  with PreProcessor do
  begin
    Version := 200;
  end;  
  InPDir := False; IsProc := False; InStruct := False; InStructHeader := False;
end;
 
function TDelphiUnit.InSubRangeSet: Boolean;
begin 
   
  Result := ((CurrentInputSymbol=identSym)and(MatchStr(LexNames[1],['HIGH','LOW','SIZEOF'])))
        or
           ((Symbols[2]^.Id) in [_point_pointSym,_plusSym,_minusSym,
                    _greater_equalSym,_less_greaterSym,ORSym,XORSym,_starSym,
                    _slashSym,DIVSym,MODSym,ANDSym,SHLSym,SHRSym]);
end;  
 
procedure TDelphiUnit.ProcessDelphiPragma(const str: String);

  function DelphiCond(var aName: String): Integer;
  begin
    Result := 0;
    if Pos('{$IFDEF',aName)=1 then
    begin
      aName := Trim(Copy(aName,8,Length(aName)-8));
      Result := 1;
    end else if Pos('{$IFNDEF',aName)=1 then
    begin
      aName := Trim(Copy(aName,9,Length(aName)-9));
      Result := 2;
    end else if Pos('{$IFEND',aName)=1 then
      Result := 6
    else if Pos('{$IFOPT',aName)=1 then
    begin
      aName := Trim(Copy(aName,8,Length(aName)-8));
      Result := 9;
    end else if Pos('{$IF',aName)=1 then
    begin
      aName := Trim(Copy(aName,5,Length(aName)-5));
      Result := 7;
    end else if Pos('{$INCLUDE',aName)=1 then
    begin
      aName := Trim(Copy(aName,10,Length(aName)-10));
      Result := 10;
    end else if Pos('{$I',aName)=1 then
    begin
      aName := Trim(Copy(aName,4,Length(aName)-4));
      Result := 10;
    end else if Pos('{$DEFINE',aName)=1 then
    begin
      aName := Trim(Copy(aName,9,Length(aName)-9));
      Result := 3;
    end else if Pos('{$UNDEF',aName)=1 then
    begin
      aName := Trim(Copy(aName,8,Length(aName)-8));
      Result := 4;
    end else if Pos('{$ELSEIF',aName)=1 then
    begin
      aName := Trim(Copy(aName,9,Length(aName)-9));
      Result := 8;
    end else if Pos('{$ELSE',aName)=1 then
      Result := 5
    else if Pos('{$ENDIF',aName)=1 then
      Result := 6;
  end;

  procedure Skip;
  var rec: TSymbolRec;
      id: String;
      c: Integer;
  begin
    c := 1;
    while True do
    begin
      repeat
        Scanner.Get(rec);
      until rec.Id in [_EOFSYMB,DelphiPragmaSym];
      if rec.Id =_EOFSYMB then
        Exit;

      id := Scanner.getSymbolText(@rec);
      case DelphiCond(id) of
        1,2:  Inc(C);
        5:  if c=1 then Break;
        6:  begin
             Dec(c);
             if c=0 then Break;
            end;
        8: if (c=1)and PreProcessor.Evaluate(id) then
              Break;
      end;
    end;
  end;

var id: String;
begin
  id := str;
  with PreProcessor do
  case DelphiCond(id) of
    1: if not Defined[id] then Skip;
    2: if Defined[id] then Skip;
    3: Defined[id] := True;
    4: Defined[id] := False;
    5: Skip;
    7,8: if not Evaluate(id) then Skip;
    10: IncludeFile(id);
  end;
end;

procedure TDelphiUnit._DelphiUnit;
begin
  Expect(UNITSym);
  _Qualident;
    InPDir:=True;
  while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
  begin
    _PortabilityDirective;
  end;
    InPDir:=False;
  Expect(_sclSym);
  Expect(intfSym);
  _InterfaceBody;
  Expect(implSym);
       Exit; 
end;

procedure TDelphiUnit._Qualident;
begin
  Expect(identSym);
  while (CurrentInputSymbol=_pointSym) do
  begin
    Get;
    Expect(identSym);
  end;
end;

procedure TDelphiUnit._PortabilityDirective;
begin
  if (CurrentInputSymbol=deprSym) then
  begin
       Get;
       if (CurrentInputSymbol=stringSym) then
       begin
         Get;
       end;
  end
  else if (CurrentInputSymbol=plfmSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=libSym) then
  begin
       Get;
  end
  else SynError(1);
end;

procedure TDelphiUnit._InterfaceBody;
begin
  if (CurrentInputSymbol=USESSym) then
  begin
    Get;
    _UsesClause;
    Expect(_sclSym);
  end;
  while InSet(CurrentInputSymbol,0) do
  begin
    while not InSet(CurrentInputSymbol,1) do
    begin SynError(2); Get; end;
    _InterfaceDecl;
  end;
end;

procedure TDelphiUnit._UsesClause;
begin
  _QualidentList;
end;

procedure TDelphiUnit._InterfaceDecl;
begin
  if (CurrentInputSymbol in [CONSTSym, VARSym]) then
  begin
       if (CurrentInputSymbol=CONSTSym) then
       begin
            Get;
            _ConstantDecl;
            while (CurrentInputSymbol=identSym) do
            begin
              _ConstantDecl;
            end;
       end
       else if (CurrentInputSymbol=VARSym) then
       begin
            Get;
            _VarDecl;
            while (CurrentInputSymbol=identSym) do
            begin
              _VarDecl;
            end;
       end
       ;
  end
  else if (CurrentInputSymbol=TYPESym) then
  begin
       Get;
       _TypeDecl;
       while (CurrentInputSymbol in [identSym, _lbrackSym]) do
       begin
         _TypeDecl;
       end;
  end
  else if (CurrentInputSymbol in [procSym, FUNCTIONSym]) then
  begin
       _ExportedHeading;
  end
  else if (CurrentInputSymbol=ressSym) then
  begin
      InPDir:=True;
       Get;
       _ResourceString;
       while (CurrentInputSymbol=identSym) do
       begin
         _ResourceString;
       end;
                                     InPDir:=False;
  end
  else SynError(3);
end;

procedure TDelphiUnit._QualidentList;
begin
  _Qualident;
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _Qualident;
  end;
end;

procedure TDelphiUnit._ConstantDecl;
begin
  Expect(identSym);
  if (CurrentInputSymbol=_colonSym) then
  begin
       Get;
       _Type;
       Expect(_equalSym);
       _ConstExprOrStructConst;
  end
  else if (CurrentInputSymbol=_equalSym) then
  begin
       Get;
       _ConstExpr;
  end
  else SynError(4);
    InPDir:=True;
  while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
  begin
    _PortabilityDirective;
  end;
    InPDir:=False;
  Expect(_sclSym);
end;

procedure TDelphiUnit._VarDecl;
begin
  _IdentList;
  Expect(_colonSym);
  _Type;
    if not IsProc then InPDir:=True;
  if InSet(CurrentInputSymbol,2) and (not IsProc) then
  begin
       if (CurrentInputSymbol=absSym) then
       begin
            Get;
            Expect(identSym);
       end
       else if InSet(CurrentInputSymbol,3) then
       begin
            while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
            begin
              _PortabilityDirective;
            end;
            InPDir:=False;
            if (CurrentInputSymbol=_equalSym) then
            begin
              Get;
              _ConstExprOrStructConst;
            end;
       end
       else SynError(5);
       Expect(_sclSym);
  end
  else if (CurrentInputSymbol in [_sclSym, _equalSym]) then
  begin
       if (CurrentInputSymbol=_equalSym) then
       begin
            Get;
            _ConstExpr;
            Expect(_sclSym);
       end
       else if (CurrentInputSymbol=_sclSym) then
       begin
            Get;
            if InSet(CurrentInputSymbol,4) then
            begin
              _Directive;
              while InSet(CurrentInputSymbol,4) do
              begin
                _Directive;
              end;
              if (CurrentInputSymbol=_equalSym) then
              begin
                Get;
                _ConstExpr;
              end;
              Expect(_sclSym);
            end;
       end
       ;
  end
  else SynError(5);
      IsProc:=False;
end;

procedure TDelphiUnit._TypeDecl;
begin
  while (CurrentInputSymbol=_lbrackSym) do
  begin
    _DotNetAttr;
  end;
  Expect(identSym);
  if (CurrentInputSymbol=_lessSym) then
  begin
    _GenericDecl;
  end;
  Expect(_equalSym);
  if (CurrentInputSymbol=CLASSSym) and (Symbols[2]^.Id<>OFSym) then
  begin
       _ClassType;
  end
  else if (CurrentInputSymbol=OBJECTSym) then
  begin
       _ObjectType;
  end
  else if (CurrentInputSymbol in [intfSym, dintfSym]) then
  begin
       _InterfaceType;
  end
  else if InSet(CurrentInputSymbol,5) then
  begin
       if (CurrentInputSymbol=TYPESym) then
       begin
         Get;
       end;
       _Type;
  end
  else SynError(6);
     if not IsProc then InPDir:=True;
  if InSet(CurrentInputSymbol,6) and (not IsProc) then
  begin
       while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
       begin
         _PortabilityDirective;
       end;
        InPDir:=False;
       Expect(_sclSym);
  end
  else if (CurrentInputSymbol=_sclSym) then
  begin
       Get;
       if InSet(CurrentInputSymbol,4) then
       begin
         _Directive;
         while InSet(CurrentInputSymbol,4) do
         begin
           _Directive;
         end;
         Expect(_sclSym);
       end;
        IsProc:=False;
  end
  else SynError(6);
end;

procedure TDelphiUnit._ExportedHeading;
begin
  if (CurrentInputSymbol=procSym) then
  begin
       Get;
       Expect(identSym);
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters;
       end;
  end
  else if (CurrentInputSymbol=FUNCTIONSym) then
  begin
       Get;
       Expect(identSym);
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters;
       end;
       Expect(_colonSym);
       _TypeId;
  end
  else SynError(7);
    IsProc:=True;
  while InSet(CurrentInputSymbol,4) do
  begin
    _Directive;
  end;
    InPDir:=True;
  while (CurrentInputSymbol=_sclSym) do
  begin
    Get;
    if (CurrentInputSymbol in [deprSym, plfmSym, libSym]) then
    begin
         _PortabilityDirective;
    end
    else if InSet(CurrentInputSymbol,4) then
    begin
         _Directive;
    end
    else if InSet(CurrentInputSymbol,7) then
    begin
            Break
    end
    else SynError(7);
    while InSet(CurrentInputSymbol,8) do
    begin
      if (CurrentInputSymbol in [deprSym, plfmSym, libSym]) then
      begin
           _PortabilityDirective;
      end
      else if InSet(CurrentInputSymbol,4) then
      begin
           _Directive;
      end
      ;
    end;
  end;
      IsProc:=False; InPDir:=False;
end;

procedure TDelphiUnit._ResourceString;
begin
  Expect(identSym);
  Expect(_equalSym);
  _Expression;
  if (CurrentInputSymbol=deprSym) then
  begin
    Get;
    if (CurrentInputSymbol=stringSym) then
    begin
      Get;
    end;
  end;
  Expect(_sclSym);
end;

procedure TDelphiUnit._TypeId;
begin
  if (CurrentInputSymbol=identSym) then
  begin
       _GQualident;
  end
  else if (CurrentInputSymbol=strSym) then
  begin
       Get;
  end
  else SynError(8);
end;

procedure TDelphiUnit._GQualident;
begin
  _Qualident;
  if (CurrentInputSymbol=_lessSym) then
  begin
    Get;
    if (CurrentInputSymbol=identSym) then
    begin
         _GQualident;
    end
    else if (CurrentInputSymbol=strSym) then
    begin
         Get;
    end
    else SynError(9);
    while (CurrentInputSymbol=_commaSym) do
    begin
      Get;
      if (CurrentInputSymbol=identSym) then
      begin
           _GQualident;
      end
      else if (CurrentInputSymbol=strSym) then
      begin
           Get;
      end
      else SynError(9);
    end;
    Expect(_greaterSym);
  end;
end;

procedure TDelphiUnit._Type;
begin
  if (CurrentInputSymbol=strSym) then
  begin
       Get;
       if (CurrentInputSymbol=_lbrackSym) then
       begin
         Get;
         _ConstExpr;
         Expect(_rbrackSym);
       end;
  end
  else if (CurrentInputSymbol=_lparenSym) then
  begin
       _EnumeratedType;
  end
  else if (CurrentInputSymbol=identSym) and (LexNames[1]='REFERENCE') then
  begin
       Expect(identSym);
       Expect(TOSym);
       _ProcedureType;
  end
  else if (CurrentInputSymbol=identSym) and ( not InSubRangeSet) then
  begin
       _GQualident;
       if (CurrentInputSymbol=_lparenSym) and (LexName='ANSISTRING') then
       begin
         Expect(_lparenSym);
         if (CurrentInputSymbol=numberSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=hexnumberSym) then
         begin
              Get;
         end
         else SynError(10);
         Expect(_rparenSym);
       end;
  end
  else if InSet(CurrentInputSymbol,9) then
  begin
       _SubrangeType;
  end
  else if (CurrentInputSymbol=_uparrowSym) then
  begin
       _PointerType;
  end
  else if InSet(CurrentInputSymbol,10) then
  begin
       _StrucType;
  end
  else if (CurrentInputSymbol=CLASSSym) then
  begin
       _ClassRefType;
  end
  else if (CurrentInputSymbol in [procSym, FUNCTIONSym]) then
  begin
       _ProcedureType;
  end
  else SynError(10);
end;

procedure TDelphiUnit._ConstExprOrStructConst;
begin
  if (CurrentInputSymbol=_lparenSym) then
  begin
       Get;
       if (CurrentInputSymbol=identSym) and ( Symbols[2]^.id=_colonSym ) then
       begin
            Expect(identSym);
            Expect(_colonSym);
            _ConstExprOrStructConst;
            while (CurrentInputSymbol=_sclSym) do
            begin
              Get;
              if (CurrentInputSymbol=identSym) then
              begin
                   Get;
                   Expect(_colonSym);
                   _ConstExprOrStructConst;
              end
              else if (CurrentInputSymbol in [_sclSym, _rparenSym]) then
              begin
                Break;
              end
              else SynError(11);
            end;
       end
       else if InSet(CurrentInputSymbol,9) then
       begin
            _ConstExprOrStructConst;
            while (CurrentInputSymbol=_commaSym) do
            begin
              Get;
              _ConstExprOrStructConst;
            end;
       end
       else SynError(11);
       Expect(_rparenSym);
  end
  else if InSet(CurrentInputSymbol,9) then
  begin
       _ConstExpr;
  end
  else SynError(11);
end;

procedure TDelphiUnit._ConstExpr;
begin
  _Expression;
end;

procedure TDelphiUnit._DotNetAttr;
begin
  Expect(_lbrackSym);
  while InSet(CurrentInputSymbol,11) do
  begin
    Get;
  end;
  Expect(_rbrackSym);
end;

procedure TDelphiUnit._GenericDecl;
begin
  Expect(_lessSym);
  if (CurrentInputSymbol=identSym) then
  begin
    _GParm;
    while (CurrentInputSymbol=_sclSym) do
    begin
      Get;
      _GParm;
    end;
  end;
  Expect(_greaterSym);
end;

procedure TDelphiUnit._ClassType;
begin
     InStruct:=True; InStructHeader := True;
  Expect(CLASSSym);
  if (CurrentInputSymbol in [ABSTRACTSym, HELPERSym, SEALEDSym]) then
  begin
    if (CurrentInputSymbol=HELPERSym) then
    begin
         Get;
         Expect(FORSym);
         _GQualident;
    end
    else if (CurrentInputSymbol=ABSTRACTSym) then
    begin
         Get;
    end
    else if (CurrentInputSymbol=SEALEDSym) then
    begin
         Get;
    end
    ;
  end;
       InStructHeader := False;
  if (CurrentInputSymbol=_lparenSym) then
  begin
    Get;
    _GQualidentList;
    Expect(_rparenSym);
  end;
  if InSet(CurrentInputSymbol,12) then
  begin
    _ClassBody;
  end;
end;

procedure TDelphiUnit._ObjectType;
begin
    InStruct:= True;
  Expect(OBJECTSym);
  if (CurrentInputSymbol=_lparenSym) then
  begin
    Get;
    _QualidentList;
    Expect(_rparenSym);
  end;
  if InSet(CurrentInputSymbol,12) then
  begin
    _ClassBody;
  end;
end;

procedure TDelphiUnit._InterfaceType;
begin
  if (CurrentInputSymbol=intfSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=dintfSym) then
  begin
       Get;
  end
  else SynError(12);
  if InSet(CurrentInputSymbol,13) then
  begin
    if (CurrentInputSymbol=_lparenSym) then
    begin
      Get;
      _GQualidentList;
      Expect(_rparenSym);
    end;
    if (CurrentInputSymbol=_lbrackSym) then
    begin
      Get;
      if (CurrentInputSymbol=stringSym) then
      begin
           Get;
      end
      else if (CurrentInputSymbol=identSym) then
      begin
           Get;
      end
      else SynError(12);
      Expect(_rbrackSym);
    end;
    while InSet(CurrentInputSymbol,14) do
    begin
      if (CurrentInputSymbol in [procSym, _lbrackSym, FUNCTIONSym]) then
      begin
           _IMethodHeading;
      end
      else if (CurrentInputSymbol=PROPERTYSym) then
      begin
           _Property;
      end
      ;
    end;
    Expect(ENDSym);
  end;
end;

procedure TDelphiUnit._Directive;
begin
  if (CurrentInputSymbol=CDECLSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=REGISTERSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=DYNAMICSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=VIRTUALSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=EXPORTSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=EXTERNALSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=NEARSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=FARSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=FORWARDSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=OVERRIDESym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=OVERLOADSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=PASCALSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=REINTRODUCESym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=SAFECALLSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=STDCALLSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=VARARGSSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=ABSTRACTSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=INLINESym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=ASSEMBLERSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=STATICSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=FINALSym) then
  begin
       Get;
  end
  else SynError(13);
end;

procedure TDelphiUnit._IdentList;
begin
  Expect(identSym);
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    Expect(identSym);
  end;
end;

procedure TDelphiUnit._EnumeratedType;
begin
  Expect(_lparenSym);
  _EnumeratedTypeElement;
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _EnumeratedTypeElement;
  end;
  Expect(_rparenSym);
end;

procedure TDelphiUnit._ProcedureType;
begin
  if (CurrentInputSymbol=procSym) then
  begin
       Get;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters;
       end;
  end
  else if (CurrentInputSymbol=FUNCTIONSym) then
  begin
       Get;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters;
       end;
       Expect(_colonSym);
       _TypeId;
  end
  else SynError(14);
  if (CurrentInputSymbol=OFSym) then
  begin
    Get;
    Expect(OBJECTSym);
  end;
   IsProc:=True;
  while InSet(CurrentInputSymbol,4) do
  begin
    _Directive;
  end;
end;

procedure TDelphiUnit._SubrangeType;
begin
  _ConstExpr;
  Expect(_point_pointSym);
  _ConstExpr;
end;

procedure TDelphiUnit._PointerType;
begin
  Expect(_uparrowSym);
  _TypeId;
end;

procedure TDelphiUnit._StrucType;
begin
  if (CurrentInputSymbol=PACKEDSym) then
  begin
    Get;
  end;
  if (CurrentInputSymbol=ARRAYSym) then
  begin
       _ArrayType;
  end
  else if (CurrentInputSymbol=SETSym) then
  begin
       _SetType;
  end
  else if (CurrentInputSymbol=FILESym) then
  begin
       _FileType;
  end
  else if (CurrentInputSymbol=RECORDSym) then
  begin
       _RecType;
  end
  else SynError(15);
end;

procedure TDelphiUnit._ClassRefType;
begin
  Expect(CLASSSym);
  Expect(OFSym);
  _Qualident;
end;

procedure TDelphiUnit._EnumeratedTypeElement;
begin
  Expect(identSym);
  if (CurrentInputSymbol=_equalSym) then
  begin
    Get;
    _ConstExpr;
  end;
end;

procedure TDelphiUnit._ArrayType;
begin
  Expect(ARRAYSym);
  if (CurrentInputSymbol=_lbrackSym) then
  begin
    Get;
    _ArrayIndexType;
    while (CurrentInputSymbol=_commaSym) do
    begin
      Get;
      _ArrayIndexType;
    end;
    Expect(_rbrackSym);
  end;
  Expect(OFSym);
  _Type;
  if (CurrentInputSymbol=_sclSym) and (IsProc and (Abs(Symbols[2]^.id) in [CDECLSym..ASSEMBLERSym])) then
  begin
    Expect(_sclSym);
    _Directive;
    while InSet(CurrentInputSymbol,4) do
    begin
      _Directive;
    end;
  end;
      IsProc:=False;
end;

procedure TDelphiUnit._SetType;
begin
  Expect(SETSym);
  Expect(OFSym);
  if InSet(CurrentInputSymbol,9) and ( InSubRangeSet) then
  begin
       _SubrangeType;
  end
  else if (CurrentInputSymbol=_lparenSym) then
  begin
       _EnumeratedType;
  end
  else if (CurrentInputSymbol=identSym) then
  begin
       _Qualident;
  end
  else SynError(16);
end;

procedure TDelphiUnit._FileType;
begin
  Expect(FILESym);
  Expect(OFSym);
  _Type;
end;

procedure TDelphiUnit._RecType;
begin
     InStruct:=True; InStructHeader := True;
  Expect(RECORDSym);
  if (CurrentInputSymbol=HELPERSym) then
  begin
    Get;
    Expect(FORSym);
    _GQualident;
  end;
       InStructHeader := False;
  if InSet(CurrentInputSymbol,15) then
  begin
    _RecBody;
  end;
end;

procedure TDelphiUnit._ArrayIndexType;
begin
  if (CurrentInputSymbol=_lparenSym) then
  begin
       _EnumeratedType;
  end
  else if (CurrentInputSymbol=identSym) and ( not InSubRangeSet) then
  begin
       _Qualident;
  end
  else if InSet(CurrentInputSymbol,9) then
  begin
       _SubrangeType;
  end
  else SynError(17);
end;

procedure TDelphiUnit._RecBody;
begin
  while InSet(CurrentInputSymbol,16) do
  begin
    if InSet(CurrentInputSymbol,17) then
    begin
         if (CurrentInputSymbol=STRICTSym) then
         begin
           Get;
         end;
         if (CurrentInputSymbol=PRIVATESym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=PROTECTEDSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=PUBLICSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=PUBLISHEDSym) then
         begin
              Get;
         end
         else SynError(18);
    end
    else if InSet(CurrentInputSymbol,18) then
    begin
      InStruct:=False;
         if (CurrentInputSymbol=CONSTSym) then
         begin
              Get;
              _ConstantDecl;
                          InStruct:=True;
              while (CurrentInputSymbol=identSym) do
              begin
                                               InStruct:=False;
                _ConstantDecl;
                                                                               InStruct:=True;
              end;
         end
         else if (CurrentInputSymbol=TYPESym) then
         begin
              Get;
              _TypeDecl;
                          InStruct:=True;
              while (CurrentInputSymbol in [identSym, _lbrackSym]) do
              begin
                                               InStruct:=False;
                _TypeDecl;
                                                                           InStruct:=True;
              end;
         end
         else if InSet(CurrentInputSymbol,19) then
         begin
              if (CurrentInputSymbol=CLASSSym) then
              begin
                Get;
              end;
              if (CurrentInputSymbol in [identSym, VARSym]) then
              begin
                   if (CurrentInputSymbol=VARSym) then
                   begin
                     Get;
                   end;
                   _FieldDecl;
                   if (CurrentInputSymbol=_sclSym) then
                   begin
                        Get;
                   end
                   else if InSet(CurrentInputSymbol,15) then
                   begin
                     Break
                   end
                   else SynError(18);
              end
              else if InSet(CurrentInputSymbol,20) then
              begin
                   _MethodHeading;
              end
              else if (CurrentInputSymbol=PROPERTYSym) then
              begin
                   _Property;
              end
              else SynError(18);
         end
         else if (CurrentInputSymbol=CASESym) then
         begin
              Get;
              _VariantSection;
              if (CurrentInputSymbol=_sclSym) then
              begin
                Get;
              end;
               Break
         end
         else SynError(18);
        InStruct:=True;
    end
    ;
  end;
    InStruct:=False;
  Expect(ENDSym);
end;

procedure TDelphiUnit._FieldDecl;
begin
  _IdentList;
  Expect(_colonSym);
  _Type;
    if not IsProc then InPDir:=True;
  if InSet(CurrentInputSymbol,21) and (not IsProc) then
  begin
       while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
       begin
         _PortabilityDirective;
       end;
        InPDir:=False;
  end
  else if InSet(CurrentInputSymbol,22) then
  begin
       if (CurrentInputSymbol=_sclSym) and (Abs(Symbols[2]^.id) in [CDECLSym..ASSEMBLERSym]) then
       begin
         Expect(_sclSym);
         _Directive;
         while InSet(CurrentInputSymbol,4) do
         begin
           _Directive;
         end;
       end;
        IsProc:=False;
  end
  else SynError(19);
end;

procedure TDelphiUnit._MethodHeading;
begin
  while (CurrentInputSymbol=_lbrackSym) do
  begin
    _DotNetAttr;
  end;
  if (CurrentInputSymbol=procSym) then
  begin
       Get;
       Expect(identSym);
       if (CurrentInputSymbol=_lessSym) then
       begin
         _GenericDecl;
       end;
       if InSet(CurrentInputSymbol,23) then
       begin
            if (CurrentInputSymbol=_lparenSym) then
            begin
              _FormalParameters;
            end;
       end
       else if (CurrentInputSymbol=_pointSym) then
       begin
            Get;
            _Qualident;
            Expect(_equalSym);
            Expect(identSym);
       end
       else SynError(20);
  end
  else if (CurrentInputSymbol in [identSym, FUNCTIONSym]) then
  begin
       if (CurrentInputSymbol=identSym) and (LexNames[1]='OPERATOR') then
       begin
            Expect(identSym);
       end
       else if (CurrentInputSymbol=FUNCTIONSym) then
       begin
            Get;
       end
       ;
       Expect(identSym);
       if (CurrentInputSymbol=_lessSym) then
       begin
         _GenericDecl;
       end;
       if (CurrentInputSymbol in [_colonSym, _lparenSym]) then
       begin
            if (CurrentInputSymbol=_lparenSym) then
            begin
              _FormalParameters;
            end;
            Expect(_colonSym);
            _TypeId;
       end
       else if (CurrentInputSymbol=_pointSym) then
       begin
            Get;
            _Qualident;
            Expect(_equalSym);
            Expect(identSym);
       end
       else SynError(20);
  end
  else if (CurrentInputSymbol=cntrSym) then
  begin
       Get;
       Expect(identSym);
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters;
       end;
  end
  else if (CurrentInputSymbol=destrSym) then
  begin
       Get;
       Expect(identSym);
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters;
       end;
  end
  else SynError(20);
    IsProc:=True;
  while InSet(CurrentInputSymbol,4) do
  begin
    _Directive;
  end;
    InPDir := True;
  while (CurrentInputSymbol=_sclSym) do
  begin
    Get;
    if (CurrentInputSymbol in [deprSym, plfmSym, libSym]) then
    begin
         _PortabilityDirective;
    end
    else if InSet(CurrentInputSymbol,4) then
    begin
         _Directive;
    end
    else if (CurrentInputSymbol=MESSAGESym) then
    begin
         Get;
         _ConstExpr;
    end
    else if InSet(CurrentInputSymbol,24) then
    begin
            Break
    end
    else SynError(20);
  end;
      IsProc:=False; InPDir := False;
end;

procedure TDelphiUnit._Property;
begin
  Expect(PROPERTYSym);
  Expect(identSym);
  if (CurrentInputSymbol in [_colonSym, _lbrackSym]) then
  begin
    _PropertyInterface;
  end;
    InPropSpec:=True;
  while InSet(CurrentInputSymbol,25) do
  begin
    _PropertySpecifier;
  end;
  Expect(_sclSym);
  if (CurrentInputSymbol=DEFAULTSym) then
  begin
    Get;
    Expect(_sclSym);
  end;
    InPropSpec:=False;
end;

procedure TDelphiUnit._VariantSection;
begin
  _Qualident;
  if (CurrentInputSymbol=_colonSym) then
  begin
    Get;
    _Qualident;
  end;
  Expect(OFSym);
  _RecVariant;
  while (CurrentInputSymbol=_sclSym) do
  begin
    Get;
    if InSet(CurrentInputSymbol,9) then
    begin
         _RecVariant;
    end
    else if InSet(CurrentInputSymbol,22) then
    begin
          Break;
    end
    else SynError(21);
  end;
end;

procedure TDelphiUnit._RecVariant;
begin
  _ConstExpr;
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _ConstExpr;
  end;
  Expect(_colonSym);
  Expect(_lparenSym);
  _FieldList;
  Expect(_rparenSym);
end;

procedure TDelphiUnit._FieldList;
begin
  while (CurrentInputSymbol in [identSym, CASESym]) do
  begin
    if (CurrentInputSymbol=identSym) then
    begin
         _FieldDecl;
         if (CurrentInputSymbol=_sclSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol in [identSym, _rparenSym, CASESym]) then
         begin
               Break
         end
         else SynError(22);
    end
    else if (CurrentInputSymbol=CASESym) then
    begin
         Get;
         _VariantSection;
         if (CurrentInputSymbol=_sclSym) then
         begin
           Get;
         end;
             Break
    end
    ;
  end;
end;

procedure TDelphiUnit._GQualidentList;
begin
  _GQualident;
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _GQualident;
  end;
end;

procedure TDelphiUnit._ClassBody;
begin
  while InSet(CurrentInputSymbol,26) do
  begin
    if InSet(CurrentInputSymbol,17) then
    begin
         if (CurrentInputSymbol=STRICTSym) then
         begin
           Get;
         end;
         if (CurrentInputSymbol=PRIVATESym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=PROTECTEDSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=PUBLICSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=PUBLISHEDSym) then
         begin
              Get;
         end
         else SynError(23);
    end
    else if InSet(CurrentInputSymbol,27) then
    begin
       InStruct:=False;
         if (CurrentInputSymbol=CONSTSym) then
         begin
              Get;
              _ConstantDecl;
                           InStruct:=True;
              while (CurrentInputSymbol=identSym) do
              begin
                                                 InStruct:=False;
                _ConstantDecl;
                                                                                 InStruct:=True;
              end;
         end
         else if (CurrentInputSymbol=TYPESym) then
         begin
              Get;
              _TypeDecl;
                           InStruct:=True;
              while (CurrentInputSymbol in [identSym, _lbrackSym]) do
              begin
                                                InStruct:=False;
                _TypeDecl;
                                                                            InStruct:=True;
              end;
         end
         else if InSet(CurrentInputSymbol,19) then
         begin
              if (CurrentInputSymbol=CLASSSym) then
              begin
                Get;
              end;
              if (CurrentInputSymbol in [identSym, VARSym]) then
              begin
                   if (CurrentInputSymbol=VARSym) then
                   begin
                     Get;
                   end;
                   _ObjFieldDecl;
              end
              else if InSet(CurrentInputSymbol,20) then
              begin
                   _MethodHeading;
              end
              else if (CurrentInputSymbol=PROPERTYSym) then
              begin
                   _Property;
              end
              else SynError(23);
         end
         else SynError(23);
         InStruct:=True;
    end
    ;
  end;
    InStruct:=False;
  Expect(ENDSym);
end;

procedure TDelphiUnit._IMethodHeading;
begin
  while (CurrentInputSymbol=_lbrackSym) do
  begin
    _DotNetAttr;
  end;
  if (CurrentInputSymbol=procSym) then
  begin
       Get;
       Expect(identSym);
       if (CurrentInputSymbol=_lessSym) then
       begin
         _GenericDecl;
       end;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters;
       end;
  end
  else if (CurrentInputSymbol=FUNCTIONSym) then
  begin
       Get;
       Expect(identSym);
       if (CurrentInputSymbol=_lessSym) then
       begin
         _GenericDecl;
       end;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters;
       end;
       Expect(_colonSym);
       _TypeId;
  end
  else SynError(24);
    IsProc:=True;
  while InSet(CurrentInputSymbol,4) do
  begin
    _Directive;
  end;
    InPDir:=True;
  while (CurrentInputSymbol=_sclSym) do
  begin
    Get;
    if (CurrentInputSymbol in [deprSym, plfmSym, libSym]) then
    begin
         _PortabilityDirective;
    end
    else if InSet(CurrentInputSymbol,4) then
    begin
         _Directive;
    end
    else if (CurrentInputSymbol=DISPIDSym) then
    begin
         Get;
         _ConstExpr;
    end
    else if InSet(CurrentInputSymbol,28) then
    begin
            Break
    end
    else SynError(24);
  end;
      IsProc:=False; InPDir:=False;
end;

procedure TDelphiUnit._ObjFieldDecl;
begin
  _IdentList;
  Expect(_colonSym);
  _Type;
    if not IsProc then InPDir := True;
  if InSet(CurrentInputSymbol,6) and (not IsProc) then
  begin
       while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
       begin
         _PortabilityDirective;
       end;
       Expect(_sclSym);
  end
  else if (CurrentInputSymbol=_sclSym) then
  begin
       Get;
       if InSet(CurrentInputSymbol,4) then
       begin
         _Directive;
         while InSet(CurrentInputSymbol,4) do
         begin
           _Directive;
         end;
          IsProc:=False;
         Expect(_sclSym);
       end;
         IsProc:=False;
  end
  else SynError(25);
end;

procedure TDelphiUnit._FormalParameters;
begin
  Expect(_lparenSym);
  if InSet(CurrentInputSymbol,29) then
  begin
    _FormalParm;
    while (CurrentInputSymbol=_sclSym) do
    begin
      Get;
      _FormalParm;
    end;
  end;
  Expect(_rparenSym);
end;

procedure TDelphiUnit._FormalParm;
begin
  if InSet(CurrentInputSymbol,30) then
  begin
    if (CurrentInputSymbol=VARSym) then
    begin
         Get;
    end
    else if (CurrentInputSymbol=CONSTSym) then
    begin
         Get;
    end
    else if (CurrentInputSymbol=OUTSym) then
    begin
         Get;
    end
    else if (CurrentInputSymbol=INSym) then
    begin
         Get;
    end
    ;
  end;
  _IdentList;
  if (CurrentInputSymbol=_colonSym) then
  begin
    Get;
    if (CurrentInputSymbol=ARRAYSym) then
    begin
         Get;
         Expect(OFSym);
         if (CurrentInputSymbol=CONSTSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol in [identSym, strSym]) then
         begin
              _TypeId;
         end
         else SynError(26);
    end
    else if (CurrentInputSymbol in [identSym, strSym]) then
    begin
         _TypeId;
         if (CurrentInputSymbol=_equalSym) then
         begin
           Get;
           _ConstExpr;
         end;
    end
    else SynError(26);
  end;
end;

procedure TDelphiUnit._PropertyInterface;
begin
  if (CurrentInputSymbol=_lbrackSym) then
  begin
    Get;
    _FormalParm;
    while (CurrentInputSymbol=_sclSym) do
    begin
      Get;
      _FormalParm;
    end;
    Expect(_rbrackSym);
  end;
  Expect(_colonSym);
  _TypeId;
end;

procedure TDelphiUnit._PropertySpecifier;
begin
  if (CurrentInputSymbol in [INDEXSym, DEFAULTSym, DISPIDSym]) then
  begin
       if (CurrentInputSymbol=INDEXSym) then
       begin
            Get;
       end
       else if (CurrentInputSymbol=DEFAULTSym) then
       begin
            Get;
       end
       else if (CurrentInputSymbol=DISPIDSym) then
       begin
            Get;
       end
       ;
       _ConstExpr;
  end
  else if (CurrentInputSymbol in [READSym, WRITESym]) then
  begin
       if (CurrentInputSymbol=READSym) then
       begin
            Get;
       end
       else if (CurrentInputSymbol=WRITESym) then
       begin
            Get;
       end
       ;
       _Qualident;
  end
  else if (CurrentInputSymbol=STOREDSym) then
  begin
       Get;
       _Expression;
  end
  else if (CurrentInputSymbol=IMPLEMENTSSym) then
  begin
       Get;
       _QualidentList;
  end
  else if (CurrentInputSymbol=NODEFAULTSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=READONLYSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=WRITEONLYSym) then
  begin
       Get;
  end
  else SynError(27);
end;

procedure TDelphiUnit._Expression;
begin
  _SimpleExpression;
  while InSet(CurrentInputSymbol,31) do
  begin
    _RelOp;
    _SimpleExpression;
  end;
end;

procedure TDelphiUnit._SimpleExpression;
begin
  if (CurrentInputSymbol in [_plusSym, _minusSym]) then
  begin
    if (CurrentInputSymbol=_plusSym) then
    begin
         Get;
    end
    else if (CurrentInputSymbol=_minusSym) then
    begin
         Get;
    end
    ;
  end;
  _Term;
  while InSet(CurrentInputSymbol,32) do
  begin
    _AddOp;
    _Term;
  end;
end;

procedure TDelphiUnit._RelOp;
begin
  if (CurrentInputSymbol=_greaterSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_lessSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_less_equalSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_greater_equalSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_less_greaterSym) then
  begin
       Get;
  end
  else SynError(28);
end;

procedure TDelphiUnit._Term;
begin
  _Factor;
  while InSet(CurrentInputSymbol,33) do
  begin
    _MulOp;
    _Factor;
  end;
end;

procedure TDelphiUnit._AddOp;
begin
  if (CurrentInputSymbol=_plusSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_minusSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=ORSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=XORSym) then
  begin
       Get;
  end
  else SynError(29);
end;

procedure TDelphiUnit._Factor;
begin
  if (CurrentInputSymbol in [numberSym, floatSym, hexnumberSym]) then
  begin
       _Number;
  end
  else if (CurrentInputSymbol=stringSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=NILSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=NOTSym) then
  begin
       Get;
       _Factor;
  end
  else if (CurrentInputSymbol=_lbrackSym) then
  begin
       _SetConstructor;
  end
  else if (CurrentInputSymbol in [identSym, _atSym]) then
  begin
       _Designator;
  end
  else if (CurrentInputSymbol=_lparenSym) then
  begin
       Get;
       _Expression;
       Expect(_rparenSym);
  end
  else SynError(30);
end;

procedure TDelphiUnit._MulOp;
begin
  if (CurrentInputSymbol=_starSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_slashSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=DIVSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=MODSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=ANDSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=SHLSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=SHRSym) then
  begin
       Get;
  end
  else SynError(31);
end;

procedure TDelphiUnit._Number;
begin
  if (CurrentInputSymbol=numberSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=floatSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=hexnumberSym) then
  begin
       Get;
  end
  else SynError(32);
end;

procedure TDelphiUnit._SetConstructor;
begin
  Expect(_lbrackSym);
  if InSet(CurrentInputSymbol,9) then
  begin
    _SetElement;
    while (CurrentInputSymbol=_commaSym) do
    begin
      Get;
      _SetElement;
    end;
  end;
  Expect(_rbrackSym);
end;

procedure TDelphiUnit._Designator;
begin
  if (CurrentInputSymbol=_atSym) then
  begin
    Get;
  end;
  _GQualident;
  while (CurrentInputSymbol in [_lparenSym, _lbrackSym, _uparrowSym]) do
  begin
    if (CurrentInputSymbol=_lbrackSym) then
    begin
         Get;
         _ExprList;
         Expect(_rbrackSym);
    end
    else if (CurrentInputSymbol=_lparenSym) then
    begin
         Get;
         _ExprList;
         Expect(_rparenSym);
    end
    else if (CurrentInputSymbol=_uparrowSym) then
    begin
         Get;
    end
    ;
  end;
end;

procedure TDelphiUnit._SetElement;
begin
  _Expression;
  while (CurrentInputSymbol=_point_pointSym) do
  begin
    Get;
    _Expression;
  end;
end;

procedure TDelphiUnit._ExprList;
begin
  _Expression;
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _Expression;
  end;
end;

procedure TDelphiUnit._GParm;
begin
  _IdentList;
  if (CurrentInputSymbol=_colonSym) then
  begin
    Get;
    if (CurrentInputSymbol=CLASSSym) then
    begin
         Get;
    end
    else if (CurrentInputSymbol=cntrSym) then
    begin
         Get;
    end
    else if (CurrentInputSymbol=identSym) then
    begin
         _Qualident;
    end
    else SynError(33);
  end;
end;



function TDelphiUnit.TokenToString(n: Integer): String;
const TokenStrings: array[0.._NOSYMB] of String = ('EOF'
	,'ident'	,'number'	,'string'	,'float'	,'hexnumber'
	,'";"'	,'"STRING"'	,'"CONSTRUCTOR"'	,'"DESTRUCTOR"'	,'"INTERFACE"'
	,'"DISPINTERFACE"'	,'"RESOURCESTRING"'	,'"PROCEDURE"'	,'"IMPLEMENTATION"'	,'"DEPRECATED"'
	,'"PLATFORM"'	,'"LIBRARY"'	,'"ABSOLUTE"'	,'"STRICT"'	,'"PRIVATE"'
	,'"PROTECTED"'	,'"PUBLIC"'	,'"PUBLISHED"'	,'"CDECL"'	,'"REGISTER"'
	,'"DYNAMIC"'	,'"VIRTUAL"'	,'"EXPORT"'	,'"EXTERNAL"'	,'"NEAR"'
	,'"FAR"'	,'"FORWARD"'	,'"OVERRIDE"'	,'"OVERLOAD"'	,'"PASCAL"'
	,'"REINTRODUCE"'	,'"SAFECALL"'	,'"STDCALL"'	,'"VARARGS"'	,'"INLINE"'
	,'"ASSEMBLER"'	,'"STATIC"'	,'"MESSAGE"'	,'"FINAL"'	,'"ABSTRACT"'
	,'"HELPER"'	,'"SEALED"'	,'"INDEX"'	,'"DEFAULT"'	,'"READ"'
	,'"WRITE"'	,'"STORED"'	,'"IMPLEMENTS"'	,'"NODEFAULT"'	,'"READONLY"'
	,'"WRITEONLY"'	,'"DISPID"'	,'"UNIT"'	,'"USES"'	,'"CONST"'
	,'"VAR"'	,'"TYPE"'	,'":"'	,'"="'	,'"("'
	,'","'	,'")"'	,'"["'	,'"]"'	,'"TO"'
	,'"^"'	,'".."'	,'"PACKED"'	,'"SET"'	,'"OF"'
	,'"FILE"'	,'"ARRAY"'	,'"CLASS"'	,'"RECORD"'	,'"FOR"'
	,'"CASE"'	,'"END"'	,'"OBJECT"'	,'"FUNCTION"'	,'"OUT"'
	,'"IN"'	,'"."'	,'"PROPERTY"'	,'"+"'	,'"-"'
	,'"NIL"'	,'"NOT"'	,'"@"'	,'"<"'	,'">"'
	,'"<="'	,'">="'	,'"<>"'	,'"OR"'	,'"XOR"'
	,'"*"'	,'"/"'	,'"DIV"'	,'"MOD"'	,'"AND"'
	,'"SHL"'	,'"SHR"'  ,'not');
begin
  if n in [0.._NOSYMB] then
    Result := TokenStrings[n]
  else Result := '?';
end;

function TDelphiUnit.ErrorMessage(ErrorType, ErrorCode: Integer; const data: string): String;
begin
  case ErrorCode of
	1 : Result := 'invalid PortabilityDirective';
	2 : Result := 'this symbol not expected in InterfaceBody';
	3 : Result := 'invalid InterfaceDecl';
	4 : Result := 'invalid ConstantDecl';
	5 : Result := 'invalid VarDecl';
	6 : Result := 'invalid TypeDecl';
	7 : Result := 'invalid ExportedHeading';
	8 : Result := 'invalid TypeId';
	9 : Result := 'invalid GQualident';
	10 : Result := 'invalid Type';
	11 : Result := 'invalid ConstExprOrStructConst';
	12 : Result := 'invalid InterfaceType';
	13 : Result := 'invalid Directive';
	14 : Result := 'invalid ProcedureType';
	15 : Result := 'invalid StrucType';
	16 : Result := 'invalid SetType';
	17 : Result := 'invalid ArrayIndexType';
	18 : Result := 'invalid RecBody';
	19 : Result := 'invalid FieldDecl';
	20 : Result := 'invalid MethodHeading';
	21 : Result := 'invalid VariantSection';
	22 : Result := 'invalid FieldList';
	23 : Result := 'invalid ClassBody';
	24 : Result := 'invalid IMethodHeading';
	25 : Result := 'invalid ObjFieldDecl';
	26 : Result := 'invalid FormalParm';
	27 : Result := 'invalid PropertySpecifier';
	28 : Result := 'invalid RelOp';
	29 : Result := 'invalid AddOp';
	30 : Result := 'invalid Factor';
	31 : Result := 'invalid MulOp';
	32 : Result := 'invalid Number';
	33 : Result := 'invalid GParm';


    else Result := inherited ErrorMessage(ErrorType, ErrorCode,data);
  end;
end;


procedure TDelphiUnit.ProcessPragmas;
begin
  case CurrentInputSymbol of
    DelphiPragmaSym:
	begin
                                         ProcessDelphiPragma(LexNames[1]); 
	end;
  end;

end;


function TDelphiUnit.Execute: Boolean;
begin
  Reinit;
  _DelphiUnit;
  Result := Successful;
end;


function TDelphiUnit.CreateScanner: TBaseScanner;
begin
  Result := TDelphiUnitScanner.Create(Self);
  if DelphiUnitST=nil then
  begin
    DelphiUnitST := TStartTable.Create;
    with DelphiUnitST do
    begin
	  FillRange(65, 90, 1);  States[95] := 1;  FillRange(48, 57, 28);  States[39] := 9;
	  States[35] := 10;  States[36] := 21;  States[59] := 23;  States[123] := 29;  States[40] := 46;
	  States[47] := 47;  States[58] := 31;  States[61] := 32;  States[44] := 33;  States[41] := 34;
	  States[91] := 35;  States[93] := 36;  States[94] := 37;  States[46] := 48;  States[43] := 39;
	  States[45] := 40;  States[64] := 41;  States[60] := 49;  States[62] := 50;  States[42] := 45;

    end;
    DelphiUnitLiterals := CreateLiterals(False,
	['STRING','CONSTRUCTOR','DESTRUCTOR','INTERFACE','DISPINTERFACE','RESOURCESTRING','PROCEDURE','IMPLEMENTATION'
		,'DEPRECATED','PLATFORM','LIBRARY','ABSOLUTE','STRICT','PRIVATE','PROTECTED','PUBLIC','PUBLISHED','CDECL','REGISTER'
		,'DYNAMIC','VIRTUAL','EXPORT','EXTERNAL','NEAR','FAR','FORWARD','OVERRIDE','OVERLOAD','PASCAL','REINTRODUCE','SAFECALL'
		,'STDCALL','VARARGS','INLINE','ASSEMBLER','STATIC','MESSAGE','FINAL','ABSTRACT','HELPER','SEALED','INDEX','DEFAULT'
		,'READ','WRITE','STORED','IMPLEMENTS','NODEFAULT','READONLY','WRITEONLY','DISPID','UNIT','USES','CONST','VAR','TYPE'
		,'TO','PACKED','SET','OF','FILE','ARRAY','CLASS','RECORD','FOR','CASE','END','OBJECT','FUNCTION','OUT','IN','PROPERTY'
		,'NIL','NOT','OR','XOR','DIV','MOD','AND','SHL','SHR'],
	[strSym,cntrSym,destrSym,intfSym,dintfSym,ressSym,procSym,implSym,-deprSym,-plfmSym,-libSym,-absSym,-STRICTSym,-PRIVATESym
		,-PROTECTEDSym,-PUBLICSym,-PUBLISHEDSym,-CDECLSym,-REGISTERSym,-DYNAMICSym,-VIRTUALSym,-EXPORTSym,-EXTERNALSym,-NEARSym,-FARSym
		,-FORWARDSym,-OVERRIDESym,-OVERLOADSym,-PASCALSym,-REINTRODUCESym,-SAFECALLSym,-STDCALLSym,-VARARGSSym,-INLINESym,-ASSEMBLERSym
		,-STATICSym,-MESSAGESym,-FINALSym,-ABSTRACTSym,-HELPERSym,-SEALEDSym,-INDEXSym,-DEFAULTSym,-READSym,-WRITESym,-STOREDSym,-IMPLEMENTSSym
		,-NODEFAULTSym,-READONLYSym,-WRITEONLYSym,-DISPIDSym,UNITSym,USESSym,CONSTSym,VARSym,TYPESym,TOSym,PACKEDSym,SETSym,OFSym
		,FILESym,ARRAYSym,CLASSSym,RECORDSym,FORSym,CASESym,ENDSym,OBJECTSym,FUNCTIONSym,OUTSym,INSym,PROPERTYSym,NILSym,NOTSym
		,ORSym,XORSym,DIVSym,MODSym,ANDSym,SHLSym,SHRSym]
     );
  end;
  with TDelphiUnitScanner(Result) do
  begin
    CaseInsensitive := True;  
    noSym := _NOSYMB;
    StartState := DelphiUnitST;
    Literals := DelphiUnitLiterals;
  end;
end;


constructor TDelphiUnit.Create(AOwner: TComponent);
begin
              
  PreProcessor := TDelphiCond.Create(Self);
  with PreProcessor do
  begin
   Defines := PreProcessor.Defines +'UNICODE';
   Version := 200;
  end;
  
  inherited;

  if Length(DelphiUnitSymSets)=0 then
  InitSymSets(DelphiUnitSymSets,[
    	{ 0} ressSym, procSym, CONSTSym, VARSym, TYPESym, FUNCTIONSym, -1,
	{ 1} _EOFSYMB, ressSym, procSym, CONSTSym, VARSym, TYPESym, FUNCTIONSym, -1,
	{ 2} _sclSym, deprSym, plfmSym, libSym, absSym, _equalSym, -1,
	{ 3} _sclSym, deprSym, plfmSym, libSym, _equalSym, -1,
	{ 4} CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, FINALSym, ABSTRACTSym, -1,
	{ 5} identSym, numberSym, stringSym, floatSym, hexnumberSym, strSym, procSym, TYPESym, _lparenSym, _lbrackSym, _uparrowSym, PACKEDSym, SETSym, FILESym, ARRAYSym, CLASSSym, RECORDSym, FUNCTIONSym, _plusSym, _minusSym, NILSym, NOTSym, _atSym, -1,
	{ 6} _sclSym, deprSym, plfmSym, libSym, -1,
	{ 7} _sclSym, ressSym, procSym, implSym, deprSym, plfmSym, libSym, CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, FINALSym, ABSTRACTSym, CONSTSym, VARSym, TYPESym, FUNCTIONSym, -1,
	{ 8} deprSym, plfmSym, libSym, CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, FINALSym, ABSTRACTSym, -1,
	{ 9} identSym, numberSym, stringSym, floatSym, hexnumberSym, _lparenSym, _lbrackSym, _plusSym, _minusSym, NILSym, NOTSym, _atSym, -1,
	{10} PACKEDSym, SETSym, FILESym, ARRAYSym, RECORDSym, -1,
	{11} identSym, numberSym, stringSym, floatSym, hexnumberSym, _sclSym, strSym, cntrSym, destrSym, intfSym, dintfSym, ressSym, procSym, implSym, deprSym, plfmSym, libSym, absSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, MESSAGESym, FINALSym, ABSTRACTSym, HELPERSym, SEALEDSym, INDEXSym, DEFAULTSym, READSym, WRITESym, STOREDSym, IMPLEMENTSSym, NODEFAULTSym, 
READONLYSym, WRITEONLYSym, DISPIDSym, UNITSym, USESSym, CONSTSym, VARSym, TYPESym, _colonSym, _equalSym, _lparenSym, _commaSym, _rparenSym, _lbrackSym, TOSym, _uparrowSym, _point_pointSym, PACKEDSym, SETSym, OFSym, FILESym, ARRAYSym, CLASSSym, RECORDSym, FORSym, CASESym, ENDSym, OBJECTSym, FUNCTIONSym, OUTSym, INSym, _pointSym, PROPERTYSym, _plusSym, _minusSym, NILSym, NOTSym, _atSym, _lessSym, _greaterSym, _less_equalSym, _greater_equalSym, _less_greaterSym, ORSym, XORSym, _starSym, _slashSym, DIVSym, MODSym, ANDSym, SHLSym, SHRSym, _NOSYMB, -1,
	{12} identSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _lbrackSym, CLASSSym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{13} procSym, _lparenSym, _lbrackSym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{14} procSym, _lbrackSym, FUNCTIONSym, PROPERTYSym, -1,
	{15} identSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _lbrackSym, CLASSSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{16} identSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _lbrackSym, CLASSSym, CASESym, FUNCTIONSym, PROPERTYSym, -1,
	{17} STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, -1,
	{18} identSym, cntrSym, destrSym, procSym, CONSTSym, VARSym, TYPESym, _lbrackSym, CLASSSym, CASESym, FUNCTIONSym, PROPERTYSym, -1,
	{19} identSym, cntrSym, destrSym, procSym, VARSym, _lbrackSym, CLASSSym, FUNCTIONSym, PROPERTYSym, -1,
	{20} identSym, cntrSym, destrSym, procSym, _lbrackSym, FUNCTIONSym, -1,
	{21} identSym, _sclSym, cntrSym, destrSym, procSym, deprSym, plfmSym, libSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _rparenSym, _lbrackSym, CLASSSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{22} identSym, _sclSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _rparenSym, _lbrackSym, CLASSSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{23} identSym, _sclSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, FINALSym, ABSTRACTSym, CONSTSym, VARSym, TYPESym, _lparenSym, _lbrackSym, CLASSSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{24} identSym, _sclSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _lbrackSym, CLASSSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{25} INDEXSym, DEFAULTSym, READSym, WRITESym, STOREDSym, IMPLEMENTSSym, NODEFAULTSym, READONLYSym, WRITEONLYSym, DISPIDSym, -1,
	{26} identSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _lbrackSym, CLASSSym, FUNCTIONSym, PROPERTYSym, -1,
	{27} identSym, cntrSym, destrSym, procSym, CONSTSym, VARSym, TYPESym, _lbrackSym, CLASSSym, FUNCTIONSym, PROPERTYSym, -1,
	{28} _sclSym, procSym, _lbrackSym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{29} identSym, CONSTSym, VARSym, OUTSym, INSym, -1,
	{30} CONSTSym, VARSym, OUTSym, INSym, -1,
	{31} _lessSym, _greaterSym, _less_equalSym, _greater_equalSym, _less_greaterSym, -1,
	{32} _plusSym, _minusSym, ORSym, XORSym, -1,
	{33} _starSym, _slashSym, DIVSym, MODSym, ANDSym, SHLSym, SHRSym
  ]); 
  SymSets := DelphiUnitSymSets;
  
end;

end.
