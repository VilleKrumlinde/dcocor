            
{ Copyright (C) 2009, Serge Voloshenyuk
  
  This file is Free Software and part of DCocoR
  
  It is licensed under the following three licenses as alternatives:
    1. GNU Lesser General Public License (LGPL) V2.1 or any newer version
    2. GNU General Public License (GPL) V2 or any newer version
    3. Apache License, V2.0 or any newer version
  
  You may not use this file except in compliance with at least one of
  the above three licenses.
  
  See LICENSE.txt at the top of this package for the
  complete terms and further detail along with the license texts for
  the licenses in COPYING-LIB.txt, COPYING.txt and LICENSE-2.0.txt respectively.
} 

{ This unit was generated by DCocoR.  
  Any code in this file that you edit manually will be over-written when the file is regenerated.
}

unit DelphiUnit;

interface

uses Classes,CocoAncestor,CocoGenerator,
         SysUtils,StrUtils,StreamText,DelphiCond;

type
         
  TDirective = ( ddCdecl, ddRegister, ddDynamic, ddVirtual, ddExport, ddExternal, ddNear, ddFar, ddForward,
                 ddOverride, ddOverload, ddPascal, ddReintroduce, ddSafecall, ddStdcall, ddVarargs, ddAbstract,
                 ddInline, ddSssembler, ddStatic, ddFinal );
  TDirectives = set of TDirective;


  TDelphiUnitScanner = class(TCocoRScanner)
  public
    procedure SkipIgnoreSet; override;
    procedure ScanSym(state: Integer; var sym: Integer); override;
    function SkipComments(ind: Integer): Boolean; override;
  end;


  TDelphiUnit = class(TCocoGenerator)
  
  protected
               
   SubStreamCounter: Integer;
   procedure IncludeFile(const Filename: String);
   function ImplementsList(list: TStringList; from: Integer): String;
 
    procedure _DelphiUnit;
    procedure _Qualident(out ns,name: String);
    procedure _PortabilityDirective(var val: String);
    procedure _InterfaceBody;
    procedure _UsesClause;
    procedure _InterfaceDecl;
    procedure _QualidentList(var list: TStringList);
    procedure _ConstantDecl;
    procedure _VarDecl;
    procedure _TypeDecl;
    procedure _ExportedHeading;
    procedure _ResourceString;
    procedure _TypeId(out ns,name: String);
    procedure _GQualident(out ns,name: String);
    procedure _Type(out attr, body : String);
    procedure _ConstExprOrStructConst(out val,valbody: String);
    procedure _ConstExpr(out body: String);
    procedure _DotNetAttr;
    procedure _GenericDecl(var spec: String);
    procedure _ClassType(out spec, body: String);
    procedure _ObjectType(out spec,body: String);
    procedure _InterfaceType(out spec,body: String);
    procedure _Directive(var val: TDirectives);
    procedure _IdentList(var list: TStringList);
    procedure _EnumeratedType(out val: String);
    procedure _ProcedureType(out body: String);
    procedure _SubrangeType(out val: String);
    procedure _StrucType(out body: String);
    procedure _EnumeratedTypeElement(out val: String);
    procedure _ArrayType(out attr,body: String);
    procedure _SetType(out attr,body: String);
    procedure _FileType(out attr,body: String);
    procedure _RecBody(out body: String);
    procedure _ArrayIndexType(var val: String);
    procedure _ClassSpec;
    procedure _FieldDecl(isClass: Boolean);
    procedure _MethodHeading(isClass: Boolean);
    procedure _Property(isClass: Boolean);
    procedure _VariantSection;
    procedure _RecVariant;
    procedure _FieldList;
    procedure _GQualidentList(var list: TStringList);
    procedure _ClassBody(out body: String);
    procedure _IMethodHeading;
    procedure _ObjFieldDecl(isClass: Boolean);
    procedure _FormalParameters(out body: String);
    procedure _FormalParm(var body: String);
    procedure _PropertyInterface(var attr,body: String);
    procedure _PropertySpecifier(var attr,body: String);
    procedure _Expression;
    procedure _SimpleExpression;
    procedure _RelOp;
    procedure _Term;
    procedure _AddOp;
    procedure _Factor;
    procedure _MulOp;
    procedure _Number;
    procedure _SetConstructor;
    procedure _Designator;
    procedure _SetElement;
    procedure _ExprList;
    procedure _Generics(out val: String);
    procedure _GParm;
    procedure _NopIdentList;

  public
            
   InPDir,IsProc,InPropSpec,InStruct,InStructHeader: Boolean;
   PreProcessor: TDelphiCond;
   BasePath: String;
   prefix, GlobalAttrs: String;
   function InSubRangeSet: Boolean;
   procedure CheckHomograph(var sym: Integer); override;
   procedure ProcessDelphiPragma(const str: String);
   procedure Reinit; override;
   procedure SetSourceFileName(const Filename: String); override;


    procedure ProcessPragmas; override;
    function  ErrorMessage(ErrorType,ErrorCode: Integer; const data: string): String; override;
    function  TokenToString(n: Integer): String; override;
    function  CreateScanner: TBaseScanner; override;
    function Execute: Boolean; override;

    constructor Create(AOwner: TComponent); override;

  end;

implementation

const

	identSym = 1;	numberSym = 2;	stringSym = 3;	floatSym = 4;	hexnumberSym = 5;
	_sclSym = 6;	strSym = 7;	cntrSym = 8;	destrSym = 9;	intfSym = 10;
	dintfSym = 11;	ressSym = 12;	procSym = 13;	implSym = 14;	deprSym = 15;
	plfmSym = 16;	libSym = 17;	absSym = 18;	STRICTSym = 19;	PRIVATESym = 20;
	PROTECTEDSym = 21;	PUBLICSym = 22;	PUBLISHEDSym = 23;	CDECLSym = 24;	REGISTERSym = 25;
	DYNAMICSym = 26;	VIRTUALSym = 27;	EXPORTSym = 28;	EXTERNALSym = 29;	NEARSym = 30;
	FARSym = 31;	FORWARDSym = 32;	OVERRIDESym = 33;	OVERLOADSym = 34;	PASCALSym = 35;
	REINTRODUCESym = 36;	SAFECALLSym = 37;	STDCALLSym = 38;	VARARGSSym = 39;	INLINESym = 40;
	ASSEMBLERSym = 41;	STATICSym = 42;	MESSAGESym = 43;	FINALSym = 44;	ABSTRACTSym = 45;
	HELPERSym = 46;	SEALEDSym = 47;	INDEXSym = 48;	DEFAULTSym = 49;	READSym = 50;
	WRITESym = 51;	STOREDSym = 52;	IMPLEMENTSSym = 53;	NODEFAULTSym = 54;	READONLYSym = 55;
	WRITEONLYSym = 56;	DISPIDSym = 57;	UNITSym = 58;	USESSym = 59;	CONSTSym = 60;
	VARSym = 61;	TYPESym = 62;	_colonSym = 63;	_equalSym = 64;	_lparenSym = 65;
	_commaSym = 66;	_rparenSym = 67;	CLASSSym = 68;	OBJECTSym = 69;	_lbrackSym = 70;
	_rbrackSym = 71;	TOSym = 72;	_uparrowSym = 73;	OFSym = 74;	_point_pointSym = 75;
	PACKEDSym = 76;	RECORDSym = 77;	FORSym = 78;	SETSym = 79;	FILESym = 80;
	ARRAYSym = 81;	CASESym = 82;	ENDSym = 83;	FUNCTIONSym = 84;	OUTSym = 85;
	INSym = 86;	_pointSym = 87;	PROPERTYSym = 88;	_plusSym = 89;	_minusSym = 90;
	NILSym = 91;	NOTSym = 92;	_atSym = 93;	_greaterSym = 94;	_lessSym = 95;
	_less_equalSym = 96;	_greater_equalSym = 97;	_less_greaterSym = 98;	ORSym = 99;	XORSym = 100;
	_starSym = 101;	_slashSym = 102;	DIVSym = 103;	MODSym = 104;	ANDSym = 105;
	SHLSym = 106;	SHRSym = 107;	_NOSYMB = 108;	DelphiPragmaSym = 109;	_lbraceSym = 110;
	_lparen_starSym = 111;	_slash_slashSym = 112;

var DelphiUnitSymSets: TSetArray;


var
  DelphiUnitST: TStartTable = nil;
  DelphiUnitLiterals: TStringList = nil;

{ TDelphiUnitScanner }

procedure TDelphiUnitScanner.ScanSym(state: Integer; var sym: Integer);
 var apx: TSymbolRec;
begin
 apx.Beg := -1;

 while True do
 begin
  NextCh;
  case state of
	 1:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='Z'))or(CurrInputCh='_') then
		else begin
		  sym := identSym;
		  CheckLiteral(sym);
		  Exit;
		end;
	 2:
		begin
		  EndContext(apx);
		  sym := numberSym;
		  Exit;
		end;
	 3:
		if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	 4:
		if not(((CurrInputCh>=#1)and(CurrInputCh<=#31))or(CurrInputCh='''')) then
		else if (CurrInputCh = '''') then
		  state := 3
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 5:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 6
		else if (CurrInputCh = '$') then
		  state := 7
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 6:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	 7:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		  state := 8
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 8:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		else if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	 9:
		if not(((CurrInputCh>=#1)and(CurrInputCh<=#31))or(CurrInputCh='''')) then
		else if (CurrInputCh = '''') then
		  state := 3
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	10:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 11
		else if (CurrInputCh = '$') then
		  state := 12
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	11:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	12:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		  state := 13
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	13:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		else if (CurrInputCh = '''') then
		  state := 4
		else if (CurrInputCh = '#') then
		  state := 5
		else begin
		  sym := stringSym;
		  Exit;
		end;
	14:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = 'E') then
		  state := 15
		else begin
		  sym := floatSym;
		  Exit;
		end;
	15:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 17
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 16
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	16:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 17
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	17:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else begin
		  sym := floatSym;
		  Exit;
		end;
	18:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 20
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 19
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	19:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 20
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	20:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else begin
		  sym := floatSym;
		  Exit;
		end;
	21:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		  state := 22
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	22:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F')) then
		else begin
		  sym := hexnumberSym;
		  Exit;
		end;
	23:
		begin
		  sym := _sclSym;
		  Exit;
		end;
	24:
		if not((CurrInputCh='}')) then
		else if (CurrInputCh = '}') then
		  state := 25
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	25:
		begin
		  sym := DelphiPragmaSym;
		  Exit;
		end;
	26:
		begin
		  sym := _lparen_starSym;
		  Exit;
		end;
	27:
		begin
		  sym := _slash_slashSym;
		  Exit;
		end;
	28:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '.') then
		begin   state := 30; BeginContext(apx); end
		else if (CurrInputCh = 'E') then
		  state := 18
		else begin
		  sym := numberSym;
		  Exit;
		end;
	29:
		if (CurrInputCh = '$') then
		  state := 24
		else begin
		  sym := _lbraceSym;
		  Exit;
		end;
	30:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		begin   state := 14; apx.Beg := -1; end
		else if (CurrInputCh = '.') then
		begin   state := 2; BeginContext(apx); end
		else if (CurrInputCh = 'E') then
		begin   state := 15; apx.Beg := -1; end
		else begin
		  sym := floatSym;
		  Exit;
		end;
	31:
		begin
		  sym := _colonSym;
		  Exit;
		end;
	32:
		begin
		  sym := _equalSym;
		  Exit;
		end;
	33:
		begin
		  sym := _commaSym;
		  Exit;
		end;
	34:
		begin
		  sym := _rparenSym;
		  Exit;
		end;
	35:
		begin
		  sym := _lbrackSym;
		  Exit;
		end;
	36:
		begin
		  sym := _rbrackSym;
		  Exit;
		end;
	37:
		begin
		  sym := _uparrowSym;
		  Exit;
		end;
	38:
		begin
		  sym := _point_pointSym;
		  Exit;
		end;
	39:
		begin
		  sym := _plusSym;
		  Exit;
		end;
	40:
		begin
		  sym := _minusSym;
		  Exit;
		end;
	41:
		begin
		  sym := _atSym;
		  Exit;
		end;
	42:
		begin
		  sym := _less_equalSym;
		  Exit;
		end;
	43:
		begin
		  sym := _greater_equalSym;
		  Exit;
		end;
	44:
		begin
		  sym := _less_greaterSym;
		  Exit;
		end;
	45:
		begin
		  sym := _starSym;
		  Exit;
		end;
	46:
		if (CurrInputCh = '*') then
		  state := 26
		else begin
		  sym := _lparenSym;
		  Exit;
		end;
	47:
		if (CurrInputCh = '/') then
		  state := 27
		else begin
		  sym := _slashSym;
		  Exit;
		end;
	48:
		if (CurrInputCh = '.') then
		  state := 38
		else begin
		  sym := _pointSym;
		  Exit;
		end;
	49:
		if (CurrInputCh = '=') then
		  state := 43
		else begin
		  sym := _greaterSym;
		  Exit;
		end;
	50:
		if (CurrInputCh = '=') then
		  state := 42
		else if (CurrInputCh = '>') then
		  state := 44
		else begin
		  sym := _lessSym;
		  Exit;
		end;
  
    else begin
      if CurrInputCh=#0 then
           sym := _EOFSYMB
      else sym := _NOSYMB;
      Exit;
    end;
  end;
 end;
end;


procedure TDelphiUnitScanner.SkipIgnoreSet;
begin
  while (CurrInputCh = ' ') or 
    ( (CurrInputCh=#9)or(CurrInputCh=#10)or(CurrInputCh=#13) )
  do NextCh;
end;


function TDelphiUnitScanner.SkipComments(ind: Integer): Boolean;
begin
  Result := True;
  case ind of
    _lbraceSym: SkipCommentTo('}');
    _lparen_starSym: SkipCommentTo('*)');
    _slash_slashSym: SkipCommentTo(#13);

    else Result := False;
  end;
end;



{ TDelphiUnit }

                    
 
function XMLEscape(const Str: string): string;
begin
  Result := Str;
  if Pos('&',Result)>0 then
    Result := StringReplace(Result, '&','&amp;',[rfReplaceAll]);
  if Pos('<',Result)>0 then
    Result := StringReplace(Result, '<','&lt;',[rfReplaceAll]);
  if Pos('>',Result)>0 then
    Result := StringReplace(Result, '>','&gt;',[rfReplaceAll]);
  if Pos('"',Result)>0 then
    Result := StringReplace(Result, '"','&quot;',[rfReplaceAll]);
end;

function FullIdent(const ns,name: String): String;
begin
  if ns<>'' then Result := Concat(ns,'.',name)
  else Result := name;
end;

function NameToAttr(const ns,name,attr: String): String;
begin
  Result := Format(' %s="%s"',[attr,name]);
  if ns<>'' then 
    Result := Result+Format(' %s-scope="%s"',[attr,ns]);
end;

function FullNameToAttr(const name,attr: String): String;
var I,J: Integer;
    str,ns,name1: String;
begin
  I := Pos('&amp;',name);
  if I>0 then str := Copy(name,1,I-1)
  else str := name;
  J := LastDelimiter('.', str);
  if J>0 then
  begin
    ns := Copy(str,1,J-1);
    name1 := Copy(name,J+1,Length(str));
  end else begin
    ns := '';
    name1 := name;
  end;
  Result := NameToAttr(ns,name1,attr);
end;


function Directives2String(val: TDirectives): String;
var I: TDirective;
begin
  Result := '';
  if val=[] then Exit;
  
  for I:=Low(TDirective) to High(TDirective) do
  if I in val then
  case I of
    ddCdecl:         Result := Result+' call="cdecl"';
    ddRegister:      Result := Result+' call="register"';
    ddDynamic:       Result := Result+' dynamic="true"';
    ddVirtual:       Result := Result+' virtual="true"';
    ddExport:        Result := Result+' export="true"';
    ddExternal:      Result := Result+' external="true"';
    ddNear:          Result := Result+' near="true"';
    ddFar:           Result := Result+' far="true"';
    ddOverride:      Result := Result+' override="true"';
    ddOverload:      Result := Result+' overload="true"';
    ddPascal:        Result := Result+' call="pascal"';
    ddReintroduce:   Result := Result+' reintroduce="true"';
    ddSafecall:      Result := Result+' call="safecall"';
    ddStdcall:       Result := Result+' call="stdcall"';
    ddVarargs:       Result := Result+' varargs="true"';
    ddAbstract:      Result := Result+' abstract="true"';
    ddInline:        Result := Result+' inline="true"';
    ddSssembler:     Result := Result+' sssembler="true"';
    ddStatic:        Result := Result+' static="true"';
    ddFinal:         Result := Result+' final="true"';
  end;
end;

procedure TDelphiUnit.CheckHomograph(var sym: Integer);
begin
  if ((sym=ABSTRACTSym)and not (IsProc or InStructHeader)) or
     ((sym=DISPIDSym)and not(IsProc or InPropSpec)) or
     ((sym in [deprSym..absSym])and not InPDir) or
     ((sym in [CDECLSym..FINALSym])and not IsProc) or
     ((sym in [HELPERSym,SEALEDSym])and not InStructHeader) or
     ((sym in [STRICTSym..PUBLISHEDSym])and not InStruct) or
     ((sym in [INDEXSym..WRITEONLYSym])and not InPropSpec)
  then sym := identSym;
end; 
 
procedure TDelphiUnit.SetSourceFileName(const Filename: String);
begin
  inherited;
  BasePath := ExtractFilePath(Filename);
  Outputs['STDOUT'] := TFileStream.Create(ChangeFileExt(ExtractFileName(FileName), '.xml'),fmCreate);
  SetOutput('STDOUT');
end;

procedure TDelphiUnit.IncludeFile(const Filename: String);
var fn: String;
    BMark, OldSrc,OldBase: String;
    WC,EC : Integer;
begin
  fn := ExpandFileName(BasePath+Filename);
  if FileExists(fn) then
  begin
    WC := WarnCount; EC := ErrorCount;
    BMark := Bookmark;
    OldSrc := Scanner.Source;
    try
      inherited SetSourceFileName(fn);
      OldBase := BasePath;
      BasePath := ExtractFilePath(Filename);
      _InterfaceBody;
    finally
      Scanner.SetSource(OldSrc);
      GotoBookmark(BMark);
      BasePath := OldBase;
      WarnCount := WC; ErrorCount := EC;
    end;
  end;
end;
 
procedure TDelphiUnit.Reinit;
begin
  inherited;
  with PreProcessor do
  begin
    Version := 200;
  end;  
  InPDir := False; IsProc := False; InStruct := False; InStructHeader := False;
end;
 
function TDelphiUnit.InSubRangeSet: Boolean;
begin

  Result := ((CurrentInputSymbol=identSym)and(MatchStr(LexNames[1],['HIGH','LOW','SIZEOF'])))
        or
           ((Symbols[2]^.Id) in [_point_pointSym,_plusSym,_minusSym,
                    _greater_equalSym,_less_greaterSym,ORSym,XORSym,_starSym,
                    _slashSym,DIVSym,MODSym,ANDSym,SHLSym,SHRSym]);
end;

procedure TDelphiUnit.ProcessDelphiPragma(const str: String);

  function DelphiCond(var aName: String): Integer;
  begin
    Result := 0;
    if Pos('{$IFDEF',aName)=1 then
    begin
      aName := Trim(Copy(aName,8,Length(aName)-8));
      Result := 1;
    end else if Pos('{$IFNDEF',aName)=1 then
    begin
      aName := Trim(Copy(aName,9,Length(aName)-9));
      Result := 2;
    end else if Pos('{$IFEND',aName)=1 then
      Result := 6
    else if Pos('{$IFOPT',aName)=1 then
    begin
      aName := Trim(Copy(aName,8,Length(aName)-8));
      Result := 9;
    end else if Pos('{$IF',aName)=1 then
    begin
      aName := Trim(Copy(aName,5,Length(aName)-5));
      Result := 7;
    end else if Pos('{$INCLUDE',aName)=1 then
    begin
      aName := Trim(Copy(aName,10,Length(aName)-10));
      Result := 10;
    end else if Pos('{$I',aName)=1 then
    begin
      aName := Trim(Copy(aName,4,Length(aName)-4));
      Result := 10;
    end else if Pos('{$DEFINE',aName)=1 then
    begin
      aName := Trim(Copy(aName,9,Length(aName)-9));
      Result := 3;
    end else if Pos('{$UNDEF',aName)=1 then
    begin
      aName := Trim(Copy(aName,8,Length(aName)-8));
      Result := 4;
    end else if Pos('{$ELSEIF',aName)=1 then
    begin
      aName := Trim(Copy(aName,9,Length(aName)-9));
      Result := 8;
    end else if Pos('{$ELSE',aName)=1 then
      Result := 5
    else if Pos('{$ENDIF',aName)=1 then
      Result := 6;
  end;

  procedure Skip;
  var rec: TSymbolRec;
      id: String;
      c: Integer;
  begin
    c := 1;
    while True do
    begin
      repeat
        Scanner.Get(rec);
      until rec.Id in [_EOFSYMB,DelphiPragmaSym];
      if rec.Id =_EOFSYMB then
        Exit;

      id := Scanner.getSymbolText(@rec);
      case DelphiCond(id) of
        1,2:  Inc(C);
        5:  if c=1 then Break;
        6:  begin
             Dec(c);
             if c=0 then Break;
            end;
        8: if (c=1)and PreProcessor.Evaluate(id) then
              Break;
      end;
    end;
  end;

var id: String;
begin
  id := str;
  with PreProcessor do
  case DelphiCond(id) of
    1: if not Defined[id] then Skip;
    2: if Defined[id] then Skip;
    3: Defined[id] := True;
    4: Defined[id] := False;
    5: Skip;
    7,8: if not Evaluate(id) then Skip;
    10: IncludeFile(id);
  end;
end;

function TDelphiUnit.ImplementsList(list: TStringList; from: Integer): String;
var I: Integer;
begin
  Result := '';
  if (list<>nil)and(list.Count>from) then
  begin
    for I:=from to list.Count-1 do
        Result := Format('%s<interface %s/>',[Result,FullNameToAttr(list[I],'name')]);
    Result := Format('%s   <implements>%s</implements>'#13#10,[prefix,Result]);
  end;
  list.Free;
end;

procedure TDelphiUnit._DelphiUnit;
var ns,name: String; port: String;
begin
  Expect(UNITSym);
                                  InPDir:=True;
                                  WriteLn(Output,'<?xml version="1.0"?>');
                                
  _Qualident(ns,name);
                                  InPDir:=True; port := ''; 
  while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
  begin
    _PortabilityDirective(port);
  end;
                                  InPDir:=False;
                                  WriteLn(Output,Format('<delphi_xml name="%s"%s>',
                                   [FullIdent(ns,name),port]));
                                  prefix := '  '; GlobalAttrs := '';
                                
  Expect(_sclSym);
  Expect(intfSym);
  _InterfaceBody;
  Expect(implSym);
                                  WriteLn(Output,'</delphi_xml>'); 
                                  ClearOutputs;
                                  Exit; 
end;

procedure TDelphiUnit._Qualident(out ns,name: String);
begin
  Expect(identSym);
                ns:=''; name := LexString;
  while (CurrentInputSymbol=_pointSym) do
  begin
    Get;
    Expect(identSym);
                if ns='' then
                  ns := name
                else ns := Concat(ns,'.',name);
                name := LexString;
              
  end;
end;

procedure TDelphiUnit._PortabilityDirective(var val: String);
begin
  if (CurrentInputSymbol=deprSym) then
  begin
       Get;
       if (CurrentInputSymbol=stringSym) then
       begin
         Get;
       end;
                          val := val+' deprecated="true"';
  end
  else if (CurrentInputSymbol=plfmSym) then
  begin
       Get;
                          val := val+' platform="true"';  
  end
  else if (CurrentInputSymbol=libSym) then
  begin
       Get;
                          val := val+' library="true"'; 
  end
  else SynError(1);
end;

procedure TDelphiUnit._InterfaceBody;
begin
  if (CurrentInputSymbol=USESSym) then
  begin
    Get;
    _UsesClause;
    Expect(_sclSym);
  end;
  while InSet(CurrentInputSymbol,0) do
  begin
    while not InSet(CurrentInputSymbol,1) do
    begin SynError(2); Get; end;
    _InterfaceDecl;
  end;
end;

procedure TDelphiUnit._UsesClause;
var list: TStringList; I: Integer;
begin
                                  list := TStringList.Create;
  _QualidentList(list);
                                  for I:=0 to list.Count-1 do
                                     WriteLn(Output,prefix,Format('<use ref="%s"/>',[list[I]]));
                                  list.Free;
end;

procedure TDelphiUnit._InterfaceDecl;
begin
  if (CurrentInputSymbol in [CONSTSym, VARSym]) then
  begin
       if (CurrentInputSymbol=CONSTSym) then
       begin
            Get;
            _ConstantDecl;
            while (CurrentInputSymbol=identSym) do
            begin
              _ConstantDecl;
            end;
       end
       else if (CurrentInputSymbol=VARSym) then
       begin
            Get;
            _VarDecl;
            while (CurrentInputSymbol=identSym) do
            begin
              _VarDecl;
            end;
       end
       ;
  end
  else if (CurrentInputSymbol=TYPESym) then
  begin
       Get;
       _TypeDecl;
       while (CurrentInputSymbol in [identSym, _lbrackSym]) do
       begin
         _TypeDecl;
       end;
  end
  else if (CurrentInputSymbol in [procSym, FUNCTIONSym]) then
  begin
       _ExportedHeading;
  end
  else if (CurrentInputSymbol=ressSym) then
  begin
      InPDir:=True;
       Get;
       _ResourceString;
       while (CurrentInputSymbol=identSym) do
       begin
         _ResourceString;
       end;
                                     InPDir:=False;
  end
  else SynError(3);
end;

procedure TDelphiUnit._QualidentList(var list: TStringList);
var ns,name: String;
begin
  _Qualident(ns,name);
                          if list=nil then list := TStringList.Create;
                          list.Add(FullIdent(ns,name));
                        
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _Qualident(ns,name);
                          list.Add(FullIdent(ns,name));
  end;
end;

procedure TDelphiUnit._ConstantDecl;
var cname,val,valbody: String; 
   tname,tbody,port: String;
   tail: Char;
begin
  Expect(identSym);
                                    cname := LexString; 
  if (CurrentInputSymbol=_colonSym) then
  begin
       Get;
       _Type(tname,tbody);
       Expect(_equalSym);
       _ConstExprOrStructConst(val,valbody);
  end
  else if (CurrentInputSymbol=_equalSym) then
  begin
       Get;
       _ConstExpr(val);
                                    valbody:='';
  end
  else SynError(4);
                                    InPDir:=True; port := '';
  while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
  begin
    _PortabilityDirective(port);
  end;
                                    
                                    if val<>'' then val := Format(' value="%s"',[val]);
                                    if (valbody<>'')or(tbody<>'') then
                                      tail := ' '
                                    else tail := '/';  
                                    WriteLn(Output,prefix,'<const name="',cname,'"',
                                       tname,val,GlobalAttrs,port,tail,'>');
                                    if valbody<>'' then Write(Output,valbody);
                                    if tbody<>'' then Write(Output,tbody);
                                    if tail=' ' then  WriteLn(Output,prefix,'</const>');
                                    InPDir:=False;
  Expect(_sclSym);
end;

procedure TDelphiUnit._VarDecl;
var dirs: TDirectives;
    vars: TStringList;
    I: Integer;
    val,valbody,tattr,tbody,spec: String;
begin
                                           vars := TStringList.Create;
                                           dirs := [];
                                           val := ''; spec := '';
                                         
  _IdentList(vars);
  Expect(_colonSym);
  _Type(tattr,tbody);
    if not IsProc then InPDir:=True;
  if InSet(CurrentInputSymbol,2) and (not IsProc) then
  begin
       if (CurrentInputSymbol=absSym) then
       begin
            Get;
            Expect(identSym);
                                           spec:=Format(' absolute="%s"',[LexString]);
       end
       else if InSet(CurrentInputSymbol,3) then
       begin
            while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
            begin
              _PortabilityDirective(spec);
            end;
            InPDir:=False;
            if (CurrentInputSymbol=_equalSym) then
            begin
              Get;
              _ConstExprOrStructConst(val,valbody);
            end;
       end
       else SynError(5);
       Expect(_sclSym);
  end
  else if (CurrentInputSymbol in [_sclSym, _equalSym]) then
  begin
       if (CurrentInputSymbol=_equalSym) then
       begin
            Get;
            _ConstExpr(val);
            Expect(_sclSym);
       end
       else if (CurrentInputSymbol=_sclSym) then
       begin
            Get;
            if InSet(CurrentInputSymbol,4) then
            begin
              _Directive(dirs);
              while InSet(CurrentInputSymbol,4) do
              begin
                _Directive(dirs);
              end;
              if (CurrentInputSymbol=_equalSym) then
              begin
                Get;
                _ConstExpr(val);
              end;
              Expect(_sclSym);
            end;
       end
       ;
  end
  else SynError(5);
                                           IsProc:=False;
                                           if val<>'' then val := Format(' value="%s"',[val]);
                                           if (valbody='')and(tbody='') then
                                             spec := spec+'/';
                                           for I :=0 to vars.Count-1 do
                                           begin
                                             WriteLn(Output,prefix,'<var name="',
                                                  vars[I],'" ',tattr,val,spec,GlobalAttrs,'>');
                                             if tbody<>'' then Write(Output,tbody);   
                                             if valbody<>'' then Write(Output,valbody);
                                             if (valbody<>'')or(tbody<>'') then
                                               WriteLn(Output,prefix,'</var>');
                                           end;
                                           vars.Free;
                                         
end;

procedure TDelphiUnit._TypeDecl;
var dirs: TDirectives; 
     id,type_,tattr,tbody,spec: String;

begin
  while (CurrentInputSymbol=_lbrackSym) do
  begin
    _DotNetAttr;
  end;
  Expect(identSym);
                                             id := LexString;
                                             dirs := []; spec := '';
                                             tattr:=''; tbody:='';
                                             type_ := 'type';
                                           
  if (CurrentInputSymbol=_lessSym) then
  begin
    _GenericDecl(spec);
  end;
  Expect(_equalSym);
  if (CurrentInputSymbol=CLASSSym) and (Symbols[2]^.Id<>OFSym) then
  begin
       Expect(CLASSSym);
       _ClassType(spec,tbody);
                                            type_ := 'class';
                                            if (spec='')and(tbody='') then
                                              Include(dirs,ddForward);
                                          
  end
  else if (CurrentInputSymbol=OBJECTSym) then
  begin
       Get;
       _ObjectType(spec,tbody);
                                            type_ := 'object';
                                            if (spec='')and(tbody='') then
                                              Include(dirs,ddForward);
                                          
  end
  else if (CurrentInputSymbol in [intfSym, dintfSym]) then
  begin
       if (CurrentInputSymbol=intfSym) then
       begin
            Get;
                                            type_ := 'interface';
       end
       else if (CurrentInputSymbol=dintfSym) then
       begin
            Get;
                                            type_ := 'dispinterface';
       end
       ;
       _InterfaceType(spec,tbody);
                                            if (spec='')and(tbody='') then Include(dirs,ddForward); 
  end
  else if InSet(CurrentInputSymbol,5) then
  begin
       if (CurrentInputSymbol=TYPESym) then
       begin
         Get;
                spec := ' newtype="true"';
       end;
       _Type(tattr,tbody);
  end
  else SynError(6);
                                             if not IsProc then InPDir:=True;
  if InSet(CurrentInputSymbol,6) and (not IsProc) then
  begin
       while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
       begin
         _PortabilityDirective(spec);
       end;
                                             InPDir:=False;
       Expect(_sclSym);
  end
  else if (CurrentInputSymbol=_sclSym) then
  begin
       Get;
       if InSet(CurrentInputSymbol,4) then
       begin
         _Directive(dirs);
         while InSet(CurrentInputSymbol,4) do
         begin
           _Directive(dirs);
         end;
         Expect(_sclSym);
       end;
                                             IsProc:=False;
  end
  else SynError(6);
                                              if not(ddForward in dirs) then
                                              begin
                                                if tbody='' then
                                                  spec := spec+'/';
                                                WriteLn(Output,prefix,Format('<%s name="%s"',[type_,id]),
                                                    tattr,Directives2String(dirs),spec,GlobalAttrs,'>');
                                                if tbody<>'' then
                                                begin
                                                  Write(Output,tbody);
                                                  WriteLn(Output,prefix,Format('</%s>',[type_]));
                                                end;    
                                              end;  
                                           
end;

procedure TDelphiUnit._ExportedHeading;
var dirs: TDirectives;
  id,ns,name,type_,body,spec: String;

begin
                                       body:=''; name:='';spec:='';dirs:=[];
  if (CurrentInputSymbol=procSym) then
  begin
       Get;
       Expect(identSym);
                                       type_:='procedure'; id :=LexString;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters(body);
       end;
  end
  else if (CurrentInputSymbol=FUNCTIONSym) then
  begin
       Get;
       Expect(identSym);
                                       type_:='function'; id := LexString;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters(body);
       end;
       Expect(_colonSym);
       _TypeId(ns,name);
                                       name := NameToAttr(ns,name,'return');
  end
  else SynError(7);
    IsProc:=True;
  while InSet(CurrentInputSymbol,4) do
  begin
    _Directive(dirs);
  end;
    InPDir:=True;
  while (CurrentInputSymbol=_sclSym) do
  begin
    Get;
    if (CurrentInputSymbol in [deprSym, plfmSym, libSym]) then
    begin
         _PortabilityDirective(spec);
    end
    else if InSet(CurrentInputSymbol,4) then
    begin
         _Directive(dirs);
    end
    else if InSet(CurrentInputSymbol,7) then
    begin
            Break
    end
    else SynError(7);
    while InSet(CurrentInputSymbol,8) do
    begin
      if (CurrentInputSymbol in [deprSym, plfmSym, libSym]) then
      begin
           _PortabilityDirective(spec);
      end
      else if InSet(CurrentInputSymbol,4) then
      begin
           _Directive(dirs);
      end
      ;
    end;
  end;
          IsProc:=False; InPDir:=False;
          Write(Output,prefix,Format('<%s name="%s"',[type_,id]),name, 
                Directives2String(dirs),spec);
          if body<>'' then
          begin
            WriteLn(Output,'>');
            Write(Output,body);
            WriteLn(Output,prefix,Format('</%s>',[type_]));
          end else WriteLn(Output,'/>');
        
end;

procedure TDelphiUnit._ResourceString;
var val: String;
begin
  Expect(identSym);
  Expect(_equalSym);
  _ConstExpr(val);
  if (CurrentInputSymbol=deprSym) then
  begin
    Get;
    if (CurrentInputSymbol=stringSym) then
    begin
      Get;
    end;
  end;
      WriteLn(Output,prefix,Format('<res-string value="%s"/>',[val]));
  Expect(_sclSym);
end;

procedure TDelphiUnit._TypeId(out ns,name: String);
begin
  if (CurrentInputSymbol=identSym) then
  begin
       _GQualident(ns,name);
  end
  else if (CurrentInputSymbol=strSym) then
  begin
       Get;
              ns:=''; name := 'string';
  end
  else SynError(8);
end;

procedure TDelphiUnit._GQualident(out ns,name: String);
var g: String;
begin
                        g:='';
  _Qualident(ns,name);
  if (CurrentInputSymbol=_lessSym) then
  begin
    _Generics(g);
  end;
                        name:=name+g
end;

procedure TDelphiUnit._Type(out attr, body : String);
var ns,name: String;
begin
                                                     attr:=''; body:='';
  if (CurrentInputSymbol=strSym) then
  begin
       Get;
                                                     attr:=' type="string"';
       if (CurrentInputSymbol=_lbrackSym) then
       begin
         Get;
         _ConstExpr(ns);
         Expect(_rbrackSym);
                                                     body:=Format('%s <string size="%s"/>'#13#10,[prefix,ns]); attr:='';
       end;
  end
  else if (CurrentInputSymbol=_lparenSym) then
  begin
       _EnumeratedType(body);
  end
  else if (CurrentInputSymbol=identSym) and (LexNames[1]='REFERENCE') then
  begin
       Expect(identSym);
       Expect(TOSym);
       _ProcedureType(body);
                                                     body:=Format('%s  <ref>%s'#13#10'%s  </ref>',[prefix,body,prefix]);
  end
  else if (CurrentInputSymbol=_uparrowSym) then
  begin
       Get;
       _TypeId(ns,name);
                                                     body := Format('%s <pointer %s/>'#13#10,[prefix,NameToAttr(ns,name,'type')]);
  end
  else if (CurrentInputSymbol=identSym) and ( not InSubRangeSet) then
  begin
       _GQualident(ns,name);
                                                     attr:= NameToAttr(ns,name,'type');
       if (CurrentInputSymbol=_lparenSym) and (LexName='ANSISTRING') then
       begin
         Expect(_lparenSym);
         if (CurrentInputSymbol=numberSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=hexnumberSym) then
         begin
              Get;
         end
         else SynError(9);
                                                     body:=Format('%s <ansistring codepage="%s"/>'#13#10,[prefix,LexString]); 
                                                     attr:='';
         Expect(_rparenSym);
       end;
  end
  else if InSet(CurrentInputSymbol,9) then
  begin
       _SubrangeType(body);
  end
  else if InSet(CurrentInputSymbol,10) then
  begin
       _StrucType(body);
  end
  else if (CurrentInputSymbol in [procSym, FUNCTIONSym]) then
  begin
       _ProcedureType(body);
  end
  else if (CurrentInputSymbol=CLASSSym) then
  begin
       Get;
       Expect(OFSym);
       _Qualident(ns,name);
                                                     body := Format('%s  <class-of %s/>'#13#10,[prefix,NameToAttr(ns,name,'type')]);
  end
  else SynError(9);
end;

procedure TDelphiUnit._ConstExprOrStructConst(out val,valbody: String);
var id,subval,subbody: String;
  procedure ConcatSubVal(const id: String);
  var str: String;
  begin
    if id<>'' then str := Format(' name="%s"',[id]);
    if subbody<>'' then  str := Format(#10#13'%s'#9'<item%s>%s'#10#13#9'</item>',[prefix,str,subbody])
    else str := Format(#10#13'%s'#9'<item%s value="%s"/>',[prefix,str,subval]);
    valbody := valbody+str;
  end;

begin
  if (CurrentInputSymbol=_lparenSym) then
  begin
                                                           val:='';valbody:='';
       Get;
                                                           valbody := #10#13+prefix+'  <value>';
       if (CurrentInputSymbol=identSym) and ( Symbols[2]^.id=_colonSym ) then
       begin
            Expect(identSym);
                                                           id:=LexString;    
            Expect(_colonSym);
            _ConstExprOrStructConst(subval,subbody);
                                                           ConcatSubVal(id); 
            while (CurrentInputSymbol=_sclSym) do
            begin
              Get;
              if (CurrentInputSymbol=identSym) then
              begin
                   Get;
                                                           id:=LexString;    
                   Expect(_colonSym);
                   _ConstExprOrStructConst(subval,subbody);
                                                           ConcatSubVal(id); 
              end
              else if (CurrentInputSymbol in [_sclSym, _rparenSym]) then
              begin
                Break;
              end
              else SynError(10);
            end;
       end
       else if InSet(CurrentInputSymbol,9) then
       begin
            _ConstExprOrStructConst(subval,subbody);
                                                           ConcatSubVal('');
            while (CurrentInputSymbol=_commaSym) do
            begin
              Get;
              _ConstExprOrStructConst(subval,subbody);
            end;
                                                           ConcatSubVal('');
       end
       else SynError(10);
       Expect(_rparenSym);
                                                           valbody := valbody+#10#13+prefix+'  </value>'#10#13;
  end
  else if InSet(CurrentInputSymbol,9) then
  begin
       _ConstExpr(val);
  end
  else SynError(10);
end;

procedure TDelphiUnit._ConstExpr(out body: String);
var pos: TSymbolRec;
begin
                   pos := NextSymbol^;
  _Expression;
                   pos.Len := CurSymbol^.Beg+CurSymbol^.Len-pos.Beg;
                   body := XMLEscape(Scanner.getSymbolText(@pos));
                 
end;

procedure TDelphiUnit._DotNetAttr;
begin
  Expect(_lbrackSym);
  while InSet(CurrentInputSymbol,11) do
  begin
    Get;
  end;
  Expect(_rbrackSym);
end;

procedure TDelphiUnit._GenericDecl(var spec: String);
var pos: TSymbolRec;
begin
  Expect(_lessSym);
                         pos := NextSymbol^;
  if (CurrentInputSymbol in [identSym, strSym]) then
  begin
    _GParm;
    while (CurrentInputSymbol=_sclSym) do
    begin
      Get;
      _GParm;
    end;
  end;
  Expect(_greaterSym);
                         pos.Len := CurSymbol^.Beg-pos.Beg;
                         spec := spec+Format(' generic="%s"',[XMLEscape(Scanner.getSymbolText(@pos))]);
                       
end;

procedure TDelphiUnit._ClassType(out spec, body: String);
var ns: String; list: TStringList; 
begin
                                     body:=''; spec:=''; 
                                     list := nil; 
                                     InStruct:=True; InStructHeader := True;
                                   
  if (CurrentInputSymbol in [ABSTRACTSym, HELPERSym, SEALEDSym]) then
  begin
    if (CurrentInputSymbol=HELPERSym) then
    begin
         Get;
         Expect(FORSym);
         _GQualident(ns,spec);
                                     spec := NameToAttr(spec,ns,'helper');
    end
    else if (CurrentInputSymbol=ABSTRACTSym) then
    begin
         Get;
                                     spec:=' abstract="true"';
    end
    else if (CurrentInputSymbol=SEALEDSym) then
    begin
         Get;
                                     spec:=' sealed="true"';
    end
    ;
  end;
       InStructHeader := False;
  if (CurrentInputSymbol=_lparenSym) then
  begin
    Get;
    _GQualidentList(list);
    Expect(_rparenSym);
                                     if list.Count>=1 then spec:=FullNameToAttr(list[0],'base')+spec;
  end;
  if InSet(CurrentInputSymbol,12) then
  begin
    _ClassBody(body);
  end;
                                     body := Concat(ImplementsList(list,1), body);
end;

procedure TDelphiUnit._ObjectType(out spec,body: String);
var list: TStringList;
begin
                                     body:=''; spec:=''; list:=nil; InStruct:= True;
  if (CurrentInputSymbol=_lparenSym) then
  begin
    Get;
    _QualidentList(list);
    Expect(_rparenSym);
                                     if list.Count>=1 then spec:=Format('base="%s"',[list[0]]);
  end;
  if InSet(CurrentInputSymbol,12) then
  begin
    _ClassBody(body);
  end;
                                     body := ImplementsList(list,1)+body;
end;

procedure TDelphiUnit._InterfaceType(out spec,body: String);
var ns,base,guid,oldprefix,oldGlobal: String;
  bodyStream: TStream;

begin
                                     spec:='';body:=''; bodyStream := nil;
  if InSet(CurrentInputSymbol,13) then
  begin
    if (CurrentInputSymbol=_lparenSym) then
    begin
      Get;
      _GQualident(ns,base);
      Expect(_rparenSym);
                                     spec := NameToAttr(ns,base,'base');
    end;
    if (CurrentInputSymbol=_lbrackSym) then
    begin
      Get;
      if (CurrentInputSymbol=stringSym) then
      begin
           Get;
                                     guid:=DequotedStr(LexString);
      end
      else if (CurrentInputSymbol=identSym) then
      begin
           Get;
                                     guid:=LexString;
      end
      else SynError(11);
      Expect(_rbrackSym);
                                     spec := Format('%s guid="%s"',[spec,guid]);
    end;
    while InSet(CurrentInputSymbol,14) do
    begin
      if (CurrentInputSymbol in [procSym, _lbrackSym, FUNCTIONSym]) then
      begin
                                     if bodyStream=nil then
                                     begin
                                       bodyStream := TStringStream.Create('');
                                       SwapStreamUnderTextFile(Output,bodyStream);
                                       oldprefix := prefix; prefix := prefix+'    ';
                                       oldGlobal := GlobalAttrs; GlobalAttrs := '';
                                     end;
                                   
           _IMethodHeading;
      end
      else if (CurrentInputSymbol=PROPERTYSym) then
      begin
           _Property(False);
      end
      ;
    end;
    Expect(ENDSym);
                                     if bodyStream<>nil then
                                     begin
                                       SwapStreamUnderTextFile(Output,bodyStream);
                                       body := TStringStream(bodyStream).DataString;
                                       bodyStream.Free;
                                       prefix := oldprefix;
                                       GlobalAttrs := oldGlobal;
                                     end;
                                   
  end;
end;

procedure TDelphiUnit._Directive(var val: TDirectives);
begin
  if (CurrentInputSymbol=CDECLSym) then
  begin
       Get;
                     Include(val,ddCdecl);     
  end
  else if (CurrentInputSymbol=REGISTERSym) then
  begin
       Get;
                     Include(val,ddRegister);  
  end
  else if (CurrentInputSymbol=PASCALSym) then
  begin
       Get;
                     Include(val,ddPascal);    
  end
  else if (CurrentInputSymbol=SAFECALLSym) then
  begin
       Get;
                     Include(val,ddSafecall);  
  end
  else if (CurrentInputSymbol=STDCALLSym) then
  begin
       Get;
                     Include(val,ddStdcall);   
  end
  else if (CurrentInputSymbol=DYNAMICSym) then
  begin
       Get;
                     Include(val,ddDynamic);   
  end
  else if (CurrentInputSymbol=VIRTUALSym) then
  begin
       Get;
                     Include(val,ddVirtual);   
  end
  else if (CurrentInputSymbol=EXPORTSym) then
  begin
       Get;
                     Include(val,ddExport);    
  end
  else if (CurrentInputSymbol=EXTERNALSym) then
  begin
       Get;
                     Include(val,ddExternal);  
  end
  else if (CurrentInputSymbol=NEARSym) then
  begin
       Get;
                     Include(val,ddNear);      
  end
  else if (CurrentInputSymbol=FARSym) then
  begin
       Get;
                     Include(val,ddFar);       
  end
  else if (CurrentInputSymbol=FORWARDSym) then
  begin
       Get;
                     Include(val,ddForward);   
  end
  else if (CurrentInputSymbol=OVERRIDESym) then
  begin
       Get;
                     Include(val,ddOverride);  
  end
  else if (CurrentInputSymbol=OVERLOADSym) then
  begin
       Get;
                     Include(val,ddOverload);  
  end
  else if (CurrentInputSymbol=REINTRODUCESym) then
  begin
       Get;
                     Include(val,ddReintroduce);
  end
  else if (CurrentInputSymbol=VARARGSSym) then
  begin
       Get;
                     Include(val,ddVarargs);   
  end
  else if (CurrentInputSymbol=ABSTRACTSym) then
  begin
       Get;
                     Include(val,ddAbstract);  
  end
  else if (CurrentInputSymbol=INLINESym) then
  begin
       Get;
                     Include(val,ddInline);    
  end
  else if (CurrentInputSymbol=ASSEMBLERSym) then
  begin
       Get;
                     Include(val,ddSssembler); 
  end
  else if (CurrentInputSymbol=STATICSym) then
  begin
       Get;
                     Include(val,ddStatic);    
  end
  else if (CurrentInputSymbol=FINALSym) then
  begin
       Get;
                     Include(val,ddFinal);     
  end
  else SynError(12);
end;

procedure TDelphiUnit._IdentList(var list: TStringList);
begin
  Expect(identSym);
             if list=nil then list := TStringList.Create;
             list.Add(LexString);
           
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    Expect(identSym);
             list.Add(LexString);
  end;
end;

procedure TDelphiUnit._EnumeratedType(out val: String);
var item: String;
begin
  Expect(_lparenSym);
  _EnumeratedTypeElement(val);
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _EnumeratedTypeElement(item);
                                         val:=val+item;
  end;
  Expect(_rparenSym);
                                         val:=Format('%s <enum>%s</enum>'#13#10,[prefix,val]);
end;

procedure TDelphiUnit._ProcedureType(out body: String);
var dirs: TDirectives;
   type_,ns,tname,params,spec: String;
begin
                                               spec:='';
  if (CurrentInputSymbol=procSym) then
  begin
       Get;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters(params);
       end;
                                               type_:='procedure'; tname:='';
  end
  else if (CurrentInputSymbol=FUNCTIONSym) then
  begin
       Get;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters(params);
       end;
       Expect(_colonSym);
       _TypeId(ns,tname);
                                               type_:='function';
                                               tname := NameToAttr(ns,tname,'return');
                                             
  end
  else SynError(13);
  if (CurrentInputSymbol=OFSym) then
  begin
    Get;
    Expect(OBJECTSym);
                                               spec:=' method="true"';
  end;
   IsProc:=True;
  while InSet(CurrentInputSymbol,4) do
  begin
    _Directive(dirs);
  end;
                                               body := Concat(prefix,'  <',type_,spec, tname,
                                                 Directives2String(dirs));
                                               if params<>'' then
                                                 body := Concat(body,'>'#13#10,params,prefix,Format('  </%s>'#13#10,[type_]))
                                               else body := body+'/>'#13#10;
                                             
end;

procedure TDelphiUnit._SubrangeType(out val: String);
var from_,to_: String;
begin
  _ConstExpr(from_);
  Expect(_point_pointSym);
  _ConstExpr(to_);
   val := Format('%s <range from="%s" to="%s"/>'#13#10,[prefix,from_,to_]);
end;

procedure TDelphiUnit._StrucType(out body: String);
var struct,attr,spec,ns,name: String;
begin
                           spec:='';body:='';attr:='';
  if (CurrentInputSymbol=PACKEDSym) then
  begin
    Get;
                           spec:=' packed="true"';
  end;
  if (CurrentInputSymbol=ARRAYSym) then
  begin
       _ArrayType(attr,body);
                           struct:='array';
  end
  else if (CurrentInputSymbol=SETSym) then
  begin
       _SetType(attr,body);
                           struct:='set';
  end
  else if (CurrentInputSymbol=FILESym) then
  begin
       _FileType(attr,body);
                           struct:='file';
  end
  else if (CurrentInputSymbol=RECORDSym) then
  begin
                           InStruct:=True; InStructHeader := True;
       Get;
                           struct:='record';
       if (CurrentInputSymbol=HELPERSym) then
       begin
         Get;
         Expect(FORSym);
         _GQualident(ns,name);
                           spec := spec+NameToAttr(ns,name,'helper');
       end;
                           InStructHeader := False;
       if InSet(CurrentInputSymbol,15) then
       begin
         _RecBody(body);
       end;
  end
  else SynError(14);
                           spec := Concat(prefix,'  <',struct,' ',attr,spec);
                           if body='' then
                             body := Concat(spec,'/>'#13#10)
                           else body := Concat(spec,'>'#13#10,body,prefix,'  </',struct,'>'#13#10);
                         
end;

procedure TDelphiUnit._EnumeratedTypeElement(out val: String);
var id: String;
begin
  Expect(identSym);
                         id := LexString; val := '';
  if (CurrentInputSymbol=_equalSym) then
  begin
    Get;
    _ConstExpr(val);
  end;
                         if val<>'' then val := Format(' value="%s"',[val]);
                         val := Format('<item id="%s"%s/>',[id,val]);
end;

procedure TDelphiUnit._ArrayType(out attr,body: String);
var dirs: TDirectives; idx: String;
begin
                                dirs:=[]; idx:='';
  Expect(ARRAYSym);
  if (CurrentInputSymbol=_lbrackSym) then
  begin
    Get;
    _ArrayIndexType(idx);
    while (CurrentInputSymbol=_commaSym) do
    begin
      Get;
      _ArrayIndexType(idx);
    end;
    Expect(_rbrackSym);
  end;
  Expect(OFSym);
  _Type(attr,body);
  if (CurrentInputSymbol=_sclSym) and (IsProc and (Abs(Symbols[2]^.id) in [CDECLSym..ASSEMBLERSym])) then
  begin
    Expect(_sclSym);
    _Directive(dirs);
    while InSet(CurrentInputSymbol,4) do
    begin
      _Directive(dirs);
    end;
  end;
                                IsProc:=False;
                                if dirs<>[] then
                                attr := attr+Directives2String(dirs);
                                if idx<>'' then
                                body := Concat(prefix,'  <index>'#13#10,idx,prefix,'  </index>'#13#10,body);
                              
end;

procedure TDelphiUnit._SetType(out attr,body: String);
begin
                                     attr:='';
  Expect(SETSym);
  Expect(OFSym);
  if InSet(CurrentInputSymbol,9) and ( InSubRangeSet) then
  begin
       _SubrangeType(body);
  end
  else if (CurrentInputSymbol=_lparenSym) then
  begin
       _EnumeratedType(body);
  end
  else if (CurrentInputSymbol=identSym) then
  begin
       _Qualident(body,attr);
                                     if body<>'' then body := Format(' type-scope="%s"',[body]);
                                     attr:= Format(' type="%s"%s',[attr,body]); 
                                     body:='';
  end
  else SynError(15);
end;

procedure TDelphiUnit._FileType(out attr,body: String);
begin
  Expect(FILESym);
  Expect(OFSym);
  _Type(attr,body);
end;

procedure TDelphiUnit._RecBody(out body: String);
var bodyStream: TStream; oldprefix,oldGlobal: String; isClass: Boolean;
begin
          bodyStream := TStringStream.Create('');
          SwapStreamUnderTextFile(Output,bodyStream);
          oldprefix := prefix; prefix := prefix+'  ';
          oldGlobal := GlobalAttrs; GlobalAttrs := '';
        
  while InSet(CurrentInputSymbol,16) do
  begin
    if InSet(CurrentInputSymbol,17) then
    begin
         _ClassSpec;
    end
    else if InSet(CurrentInputSymbol,18) then
    begin
      InStruct:=False;
         if (CurrentInputSymbol=CONSTSym) then
         begin
              Get;
              _ConstantDecl;
                          InStruct:=True;
              while (CurrentInputSymbol=identSym) do
              begin
                                               InStruct:=False;
                _ConstantDecl;
                                                                               InStruct:=True;
              end;
         end
         else if (CurrentInputSymbol=TYPESym) then
         begin
              Get;
              _TypeDecl;
                          InStruct:=True;
              while (CurrentInputSymbol in [identSym, _lbrackSym]) do
              begin
                                               InStruct:=False;
                _TypeDecl;
                                                                           InStruct:=True;
              end;
         end
         else if InSet(CurrentInputSymbol,19) then
         begin
              if (CurrentInputSymbol=CLASSSym) then
              begin
                   Get;
                   isClass:=True;
              end
              else if InSet(CurrentInputSymbol,20) then
              begin
                                      isClass:=False;
              end
              else SynError(16);
              if (CurrentInputSymbol in [identSym, VARSym]) then
              begin
                   if (CurrentInputSymbol=VARSym) then
                   begin
                     Get;
                   end;
                   _FieldDecl(isClass);
                   if (CurrentInputSymbol=_sclSym) then
                   begin
                        Get;
                   end
                   else if InSet(CurrentInputSymbol,15) then
                   begin
                     Break
                   end
                   else SynError(16);
              end
              else if InSet(CurrentInputSymbol,21) then
              begin
                   _MethodHeading(isClass);
              end
              else if (CurrentInputSymbol=PROPERTYSym) then
              begin
                   _Property(isClass);
              end
              else SynError(16);
         end
         else if (CurrentInputSymbol=CASESym) then
         begin
              Get;
              _VariantSection;
              if (CurrentInputSymbol=_sclSym) then
              begin
                Get;
              end;
                Break
         end
         else SynError(16);
        InStruct:=True;
    end
    ;
  end;
          InStruct:=False;
          SwapStreamUnderTextFile(Output,bodyStream);
          body := TStringStream(bodyStream).DataString;
          bodyStream.Free;
          prefix := oldprefix;
          GlobalAttrs := oldGlobal;
        
  Expect(ENDSym);
end;

procedure TDelphiUnit._ArrayIndexType(var val: String);
var ns,name: String;
begin
  if (CurrentInputSymbol=_lparenSym) then
  begin
       _EnumeratedType(ns);
                                name := Concat(prefix,'    <param>'#13#10,ns,prefix,'    </param>'#13#10);
  end
  else if (CurrentInputSymbol=identSym) and ( not InSubRangeSet) then
  begin
       _Qualident(ns,name);
                                name := Format('%s    <param %s/>'#13#10,[prefix,NameToAttr(ns,name,'type')]);
  end
  else if InSet(CurrentInputSymbol,9) then
  begin
       _SubrangeType(ns);
                                name := Concat(prefix,'    <param>'#13#10,ns,prefix,'    </param>'#13#10);
  end
  else SynError(17);
                                val:=Concat(val,name);
end;

procedure TDelphiUnit._ClassSpec;
begin
                    GlobalAttrs := '';
  if (CurrentInputSymbol=STRICTSym) then
  begin
    Get;
                    GlobalAttrs := ' strict="true"';   
  end;
  if (CurrentInputSymbol=PRIVATESym) then
  begin
       Get;
                    GlobalAttrs := GlobalAttrs+' private="true"';  
  end
  else if (CurrentInputSymbol=PROTECTEDSym) then
  begin
       Get;
                    GlobalAttrs := GlobalAttrs+' protected="true"';
  end
  else if (CurrentInputSymbol=PUBLICSym) then
  begin
       Get;
                    GlobalAttrs := GlobalAttrs+' public="true"';   
  end
  else if (CurrentInputSymbol=PUBLISHEDSym) then
  begin
       Get;
                    GlobalAttrs := GlobalAttrs+' published="true"';
  end
  else SynError(18);
end;

procedure TDelphiUnit._FieldDecl(isClass: Boolean);
var dirs: TDirectives;
  tattr,tbody,spec,sufix: String;
  vars: TStringList; I: Integer;

begin
                                            vars := TStringList.Create;spec:='';dirs:=[];
  _IdentList(vars);
  Expect(_colonSym);
  _Type(tattr,tbody);
    if not IsProc then InPDir:=True;
  if InSet(CurrentInputSymbol,22) and (not IsProc) then
  begin
       while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
       begin
         _PortabilityDirective(spec);
       end;
        InPDir:=False;
  end
  else if InSet(CurrentInputSymbol,23) then
  begin
       if (CurrentInputSymbol=_sclSym) and (Abs(Symbols[2]^.id) in [CDECLSym..ASSEMBLERSym]) then
       begin
         Expect(_sclSym);
         _Directive(dirs);
         while InSet(CurrentInputSymbol,4) do
         begin
           _Directive(dirs);
         end;
       end;
        IsProc:=False;
  end
  else SynError(19);
                                            
                                           if tbody='' then sufix := '/' else sufix := '';
                                           if isClass then tattr := tattr+' class="true"';
                                           for I :=0 to vars.Count-1 do
                                           begin
                                             WriteLn(Output,prefix,'<var name="',vars[I],'" ',
                                                  tattr, GlobalAttrs,
                                                  Directives2String(dirs),
                                                  spec,sufix,'>');
                                             if tbody<>'' then
                                             begin
                                               WriteLn(Output,tbody);   
                                               WriteLn(Output,prefix,'</var>');
                                             end; 
                                           end;
                                           vars.Free;
                                          
end;

procedure TDelphiUnit._MethodHeading(isClass: Boolean);
var id,id1,type_,ns,attr,spec: String;
   dirs: TDirectives;
   msg,params: String;

begin
  while (CurrentInputSymbol=_lbrackSym) do
  begin
    _DotNetAttr;
  end;
                                                spec := ''; dirs := [];
                                                params := ''; attr := ''; msg := '';
                                              
  if (CurrentInputSymbol=procSym) then
  begin
       Get;
       Expect(identSym);
                                                type_:='procedure'; id :=LexString;
       if (CurrentInputSymbol=_lessSym) then
       begin
         _GenericDecl(attr);
       end;
       if InSet(CurrentInputSymbol,24) then
       begin
            if (CurrentInputSymbol=_lparenSym) then
            begin
              _FormalParameters(params);
            end;
       end
       else if (CurrentInputSymbol=_pointSym) then
       begin
            Get;
            _Qualident(ns,id1);
            Expect(_equalSym);
            Expect(identSym);
                                                if ns<>'' then ns := Format('%s.%s',[id,ns])
                                                else ns := id;
                                                id := id1;
                                                type_ := 'procedure-alias';
                                                attr := Format(' interface="%s" ref="%s"',[ns,LexString]);
                                              
       end
       else SynError(20);
  end
  else if (CurrentInputSymbol in [identSym, FUNCTIONSym]) then
  begin
       if (CurrentInputSymbol=identSym) and (LexNames[1]='OPERATOR') then
       begin
            Expect(identSym);
                                                type_:='operator'; 
       end
       else if (CurrentInputSymbol=FUNCTIONSym) then
       begin
            Get;
                                                type_:='function'; 
       end
       ;
       Expect(identSym);
                                                id := LexString;
       if (CurrentInputSymbol=_lessSym) then
       begin
         _GenericDecl(attr);
       end;
       if (CurrentInputSymbol in [_colonSym, _lparenSym]) then
       begin
            if (CurrentInputSymbol=_lparenSym) then
            begin
              _FormalParameters(params);
            end;
            Expect(_colonSym);
            _TypeId(ns,id1);
                                                attr := attr+NameToAttr(ns,id1,'return');
       end
       else if (CurrentInputSymbol=_pointSym) then
       begin
            Get;
            _Qualident(ns,id1);
            Expect(_equalSym);
            Expect(identSym);
                                                if ns<>'' then ns := Format('%s.%s',[id,ns])
                                                else ns := id;
                                                id := id1;
                                                type_ := 'function-alias';
                                                attr := Format(' interface="%s" ref="%s"',[ns,LexString]);
                                              
       end
       else SynError(20);
  end
  else if (CurrentInputSymbol=cntrSym) then
  begin
       Get;
       Expect(identSym);
                                                type_:='constructor'; id :=LexString;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters(params);
       end;
  end
  else if (CurrentInputSymbol=destrSym) then
  begin
       Get;
       Expect(identSym);
                                                type_:='destructor'; id :=LexString;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters(params);
       end;
  end
  else SynError(20);
    IsProc:=True;
  while InSet(CurrentInputSymbol,4) do
  begin
    _Directive(dirs);
  end;
    InPDir := True;
  while (CurrentInputSymbol=_sclSym) do
  begin
    Get;
    if (CurrentInputSymbol in [deprSym, plfmSym, libSym]) then
    begin
         _PortabilityDirective(spec);
    end
    else if InSet(CurrentInputSymbol,4) then
    begin
         _Directive(dirs);
    end
    else if (CurrentInputSymbol=MESSAGESym) then
    begin
         Get;
         _ConstExpr(msg);
                                                attr := Format('%s message="%s"',[attr,msg]); 
    end
    else if InSet(CurrentInputSymbol,25) then
    begin
            Break
    end
    else SynError(20);
  end;
          IsProc:=False; InPDir := False;
          if isClass then attr := attr+' class="true"';
          Write(Output,prefix,Format('<%s name="%s"',[type_,id]),attr, 
                GlobalAttrs,
                Directives2String(dirs),spec);
          if params<>'' then
          begin
            WriteLn(Output,'>');
            Write(Output,params);
            WriteLn(Output,prefix,Format('</%s>',[type_]));
          end else WriteLn(Output,'/>');
        
end;

procedure TDelphiUnit._Property(isClass: Boolean);
var attr,body: String;
begin
  Expect(PROPERTYSym);
  Expect(identSym);
                               attr := Format(' name="%s"',[LexString]); body:='';
                               if isClass then attr := attr+' class="true"';
                             
  if (CurrentInputSymbol in [_colonSym, _lbrackSym]) then
  begin
    _PropertyInterface(attr,body);
  end;
                               InPropSpec:=True;
  while InSet(CurrentInputSymbol,26) do
  begin
    _PropertySpecifier(attr,body);
  end;
  Expect(_sclSym);
  if (CurrentInputSymbol=DEFAULTSym) then
  begin
    Get;
    Expect(_sclSym);
                               attr:=attr+' default="true"'
  end;
       InPropSpec:=False;
       Write(Output,prefix,'<property',attr, GlobalAttrs);
       if body<>'' then
       begin
         WriteLn(Output,'>');
         Write(Output,body);
         WriteLn(Output,prefix,'</property>');
       end else WriteLn(Output,'/>');
     
end;

procedure TDelphiUnit._VariantSection;
var ns,ns1,name,name1,attr,oldprefix: String;
begin
  _Qualident(ns,name);
                               attr:='';
  if (CurrentInputSymbol=_colonSym) then
  begin
    Get;
    _Qualident(ns1,name1);
                               attr := NameToAttr(ns1,name1,'type');
  end;
                               if attr<>'' then
                                 attr := Format(' var="%s"%s',[name,attr])
                               else attr := NameToAttr(ns,name,'type');
                               WriteLn(Output,prefix,'<variant-part',attr,'>');
                               oldprefix := prefix; prefix := prefix+'  ';
                             
  Expect(OFSym);
  _RecVariant;
  while (CurrentInputSymbol=_sclSym) do
  begin
    Get;
    if InSet(CurrentInputSymbol,9) then
    begin
         _RecVariant;
    end
    else if InSet(CurrentInputSymbol,23) then
    begin
                                          Break;
    end
    else SynError(21);
  end;
                               prefix := oldprefix;
                               WriteLn(Output,prefix,'</variant-part>');
                             
end;

procedure TDelphiUnit._RecVariant;
var lab,lab2,oldprefix: String;
begin
  _ConstExpr(lab);
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _ConstExpr(lab2);
                           lab:=Concat(lab,',',lab2)
  end;
                           WriteLn(Output,prefix,Format('<case of="%s">',[lab]));
                           oldprefix := prefix; prefix := prefix+'  ';
                         
  Expect(_colonSym);
  Expect(_lparenSym);
  _FieldList;
  Expect(_rparenSym);
                           prefix:=oldprefix; WriteLn(Output,prefix,'</case>');
end;

procedure TDelphiUnit._FieldList;
begin
  while (CurrentInputSymbol in [identSym, CASESym]) do
  begin
    if (CurrentInputSymbol=identSym) then
    begin
         _FieldDecl(False);
         if (CurrentInputSymbol=_sclSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol in [identSym, _rparenSym, CASESym]) then
         begin
               Break
         end
         else SynError(22);
    end
    else if (CurrentInputSymbol=CASESym) then
    begin
         Get;
         _VariantSection;
         if (CurrentInputSymbol=_sclSym) then
         begin
           Get;
         end;
             Break
    end
    ;
  end;
end;

procedure TDelphiUnit._GQualidentList(var list: TStringList);
var ns,name: String;
begin
  _GQualident(ns,name);
                           if list=nil then list := TStringList.Create;
                           list.Add(FullIdent(ns,name));
                         
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _GQualident(ns,name);
                           list.Add(FullIdent(ns,name));
  end;
end;

procedure TDelphiUnit._ClassBody(out body: String);
var bodyStream: TStream; oldprefix,oldGlobal: String; isClass: Boolean;
begin
          bodyStream := TStringStream.Create('');
          SwapStreamUnderTextFile(Output,bodyStream);
          oldprefix := prefix; prefix := prefix+'    ';
          oldGlobal := GlobalAttrs; GlobalAttrs := '';
        
  while InSet(CurrentInputSymbol,27) do
  begin
    if InSet(CurrentInputSymbol,17) then
    begin
         _ClassSpec;
    end
    else if InSet(CurrentInputSymbol,28) then
    begin
       InStruct:=False;
         if (CurrentInputSymbol=CONSTSym) then
         begin
              Get;
              _ConstantDecl;
                           InStruct:=True;
              while (CurrentInputSymbol=identSym) do
              begin
                                                 InStruct:=False;
                _ConstantDecl;
                                                                                 InStruct:=True;
              end;
         end
         else if (CurrentInputSymbol=TYPESym) then
         begin
              Get;
              _TypeDecl;
                           InStruct:=True;
              while (CurrentInputSymbol in [identSym, _lbrackSym]) do
              begin
                                                InStruct:=False;
                _TypeDecl;
                                                                            InStruct:=True;
              end;
         end
         else if InSet(CurrentInputSymbol,19) then
         begin
              if (CurrentInputSymbol=CLASSSym) then
              begin
                   Get;
                   isClass:=True;
              end
              else if InSet(CurrentInputSymbol,20) then
              begin
                                      isClass:=False;
              end
              else SynError(23);
              if (CurrentInputSymbol in [identSym, VARSym]) then
              begin
                   if (CurrentInputSymbol=VARSym) then
                   begin
                     Get;
                   end;
                   _ObjFieldDecl(isClass);
              end
              else if InSet(CurrentInputSymbol,21) then
              begin
                   _MethodHeading(isClass);
              end
              else if (CurrentInputSymbol=PROPERTYSym) then
              begin
                   _Property(isClass);
              end
              else SynError(23);
         end
         else SynError(23);
         InStruct:=True;
    end
    ;
  end;
          InStruct:=False;
          SwapStreamUnderTextFile(Output,bodyStream);
          body := TStringStream(bodyStream).DataString;
          bodyStream.Free;
          prefix := oldprefix;
          GlobalAttrs := oldGlobal;
        
  Expect(ENDSym);
end;

procedure TDelphiUnit._IMethodHeading;
var dirs: TDirectives;
  spec,type_,ns,name,params: String;
begin
  while (CurrentInputSymbol=_lbrackSym) do
  begin
    _DotNetAttr;
  end;
                                        dirs:=[];params:='';
  if (CurrentInputSymbol=procSym) then
  begin
       Get;
       Expect(identSym);
                                        type_:= 'procedure'; spec := Format(' name="%s"',[LexString]);
       if (CurrentInputSymbol=_lessSym) then
       begin
         _GenericDecl(spec);
       end;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters(params);
       end;
  end
  else if (CurrentInputSymbol=FUNCTIONSym) then
  begin
       Get;
       Expect(identSym);
                                        type_:='function'; spec := Format(' name="%s"',[LexString]);
       if (CurrentInputSymbol=_lessSym) then
       begin
         _GenericDecl(spec);
       end;
       if (CurrentInputSymbol=_lparenSym) then
       begin
         _FormalParameters(params);
       end;
       Expect(_colonSym);
       _TypeId(ns,name);
                                        spec := spec+NameToAttr(ns,name,'return');
  end
  else SynError(24);
    IsProc:=True;
  while InSet(CurrentInputSymbol,4) do
  begin
    _Directive(dirs);
  end;
    InPDir:=True;
  while (CurrentInputSymbol=_sclSym) do
  begin
    Get;
    if (CurrentInputSymbol in [deprSym, plfmSym, libSym]) then
    begin
         _PortabilityDirective(spec);
    end
    else if InSet(CurrentInputSymbol,4) then
    begin
         _Directive(dirs);
    end
    else if (CurrentInputSymbol=DISPIDSym) then
    begin
         Get;
         _ConstExpr(name);
                                        spec := spec+Format(' dispid="%s"',[name]);
    end
    else if InSet(CurrentInputSymbol,29) then
    begin
            Break
    end
    else SynError(24);
  end;
       IsProc:=False; InPDir:=False;
       Write(Output,prefix,'<',type_,spec,Directives2String(dirs));
       if params<>'' then
       begin
         WriteLn(Output,'>');
         Write(Output,params);
         WriteLn(Output,prefix,Format('</%s>',[type_]));
       end else WriteLn(Output,'/>');
     
end;

procedure TDelphiUnit._ObjFieldDecl(isClass: Boolean);
var dirs: TDirectives;
  vars: TStringList; I: Integer;
  tattr,tbody,spec,sufix: String;

begin
                                           vars := TStringList.Create; spec := ''; dirs :=[];
  _IdentList(vars);
  Expect(_colonSym);
  _Type(tattr,tbody);
    if not IsProc then InPDir := True;
  if InSet(CurrentInputSymbol,6) and (not IsProc) then
  begin
       while (CurrentInputSymbol in [deprSym, plfmSym, libSym]) do
       begin
         _PortabilityDirective(spec);
       end;
       Expect(_sclSym);
  end
  else if (CurrentInputSymbol=_sclSym) then
  begin
       Get;
       if InSet(CurrentInputSymbol,4) then
       begin
         _Directive(dirs);
         while InSet(CurrentInputSymbol,4) do
         begin
           _Directive(dirs);
         end;
          IsProc:=False;
         Expect(_sclSym);
       end;
         IsProc:=False;
  end
  else SynError(25);
          if tbody='' then sufix := '/' else sufix := '';
          if isClass then tattr := tattr+' class="true"';
          for I :=0 to vars.Count-1 do
          begin
            WriteLn(Output,prefix,'<var name="',vars[I],'" ',
                 tattr, GlobalAttrs,
                 Directives2String(dirs),
                 spec,sufix,'>');
            if tbody<>'' then
            begin
              WriteLn(Output,tbody);   
              WriteLn(Output,prefix,'</var>');
            end; 
          end;
          vars.Free;
end;

procedure TDelphiUnit._FormalParameters(out body: String);
begin
        body:='';
  Expect(_lparenSym);
  if InSet(CurrentInputSymbol,30) then
  begin
    _FormalParm(body);
    while (CurrentInputSymbol=_sclSym) do
    begin
      Get;
      _FormalParm(body);
    end;
  end;
  Expect(_rparenSym);
end;

procedure TDelphiUnit._FormalParm(var body: String);
var def,spec,str: String;
  ns,tname,tbody: String;
  list: TStringList; I: Integer;

begin
                              list := TStringList.Create;
                              def:=''; spec:='';tname:='';tbody:='';
                            
  if InSet(CurrentInputSymbol,31) then
  begin
    if (CurrentInputSymbol=VARSym) then
    begin
         Get;
                              spec := ' as="var"';
    end
    else if (CurrentInputSymbol=CONSTSym) then
    begin
         Get;
                              spec := ' as="const"';
    end
    else if (CurrentInputSymbol=OUTSym) then
    begin
         Get;
                              spec := ' as="out"';
    end
    else if (CurrentInputSymbol=INSym) then
    begin
         Get;
                              spec := ' as="in"';
    end
    ;
  end;
  _IdentList(list);
  if (CurrentInputSymbol=_colonSym) then
  begin
    Get;
    if (CurrentInputSymbol=ARRAYSym) then
    begin
         Get;
         Expect(OFSym);
         if (CurrentInputSymbol=CONSTSym) then
         begin
              Get;
                              tbody:= Concat(#13#10,prefix,'    <array type="const"/>'#13#10);
         end
         else if (CurrentInputSymbol in [identSym, strSym]) then
         begin
              _TypeId(ns,tname);
                              tbody := Format(#13#10'%s    <array%s/>'#13#10,[prefix,NameToAttr(ns,tname,'type')]);
                              tname:='';
                            
         end
         else SynError(26);
    end
    else if (CurrentInputSymbol in [identSym, strSym]) then
    begin
         _TypeId(ns,tname);
                              tname := NameToAttr(ns,tname,'type');
         if (CurrentInputSymbol=_equalSym) then
         begin
           Get;
           _ConstExpr(def);
                              def:=Format(' default="%s"',[def]);
         end;
    end
    else SynError(26);
  end;
                              for I:=0 to list.Count-1 do
                              begin
                                 str := Format('%s  <param%s name="%s"%s%s',[prefix,spec,list[I],tname,def]);
                                 if tbody<>'' then str := Format('%s>%s%s  </param>'#13#10,[str,tbody,prefix])
                                 else str := str+'/>'#13#10;
                                 body := body+str;
                              end;                
                              list.Free;
end;

procedure TDelphiUnit._PropertyInterface(var attr,body: String);
var ns,name,params: String;
begin
                            params:='';
  if (CurrentInputSymbol=_lbrackSym) then
  begin
    Get;
    _FormalParm(params);
    while (CurrentInputSymbol=_sclSym) do
    begin
      Get;
      _FormalParm(params);
    end;
    Expect(_rbrackSym);
  end;
  Expect(_colonSym);
  _TypeId(ns,name);
     attr := attr+NameToAttr(ns,name,'type');
     if params<>'' then
     body := Concat(body,prefix,' <index>'#13#10,params,prefix,' </index>'#13#10);
   
end;

procedure TDelphiUnit._PropertySpecifier(var attr,body: String);
var prop,ns,val: String; list: TStringList;
begin
                        prop:='';val:='true'; list:=nil;
  if InSet(CurrentInputSymbol,32) then
  begin
       if (CurrentInputSymbol=INDEXSym) then
       begin
            Get;
                        prop:='index';  
       end
       else if (CurrentInputSymbol=DEFAULTSym) then
       begin
            Get;
                        prop:='default-value';
       end
       else if (CurrentInputSymbol=DISPIDSym) then
       begin
            Get;
                        prop:='dispid'; 
       end
       else if (CurrentInputSymbol=STOREDSym) then
       begin
            Get;
                        prop:='stored'; 
       end
       ;
       _ConstExpr(val);
  end
  else if (CurrentInputSymbol in [READSym, WRITESym]) then
  begin
       if (CurrentInputSymbol=READSym) then
       begin
            Get;
                        prop:='read'; 
       end
       else if (CurrentInputSymbol=WRITESym) then
       begin
            Get;
                        prop:='write'; 
       end
       ;
       _Qualident(ns,val);
                        val:=FullIdent(ns,val);
  end
  else if (CurrentInputSymbol=IMPLEMENTSSym) then
  begin
       Get;
       _QualidentList(list);
                        body := body+ImplementsList(list,0);
  end
  else if (CurrentInputSymbol=NODEFAULTSym) then
  begin
       Get;
                        prop:='nodefault';
  end
  else if (CurrentInputSymbol=READONLYSym) then
  begin
       Get;
                        prop:='readonly'; 
  end
  else if (CurrentInputSymbol=WRITEONLYSym) then
  begin
       Get;
                        prop:='writeonly';
  end
  else SynError(27);
                        if prop<>'' then attr:=Concat(attr,Format(' %s="%s"',[prop,val]));
end;

procedure TDelphiUnit._Expression;
begin
  _SimpleExpression;
  while InSet(CurrentInputSymbol,33) do
  begin
    _RelOp;
    _SimpleExpression;
  end;
end;

procedure TDelphiUnit._SimpleExpression;
begin
  if (CurrentInputSymbol in [_plusSym, _minusSym]) then
  begin
    if (CurrentInputSymbol=_plusSym) then
    begin
         Get;
    end
    else if (CurrentInputSymbol=_minusSym) then
    begin
         Get;
    end
    ;
  end;
  _Term;
  while InSet(CurrentInputSymbol,34) do
  begin
    _AddOp;
    _Term;
  end;
end;

procedure TDelphiUnit._RelOp;
begin
  if (CurrentInputSymbol=_greaterSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_lessSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_less_equalSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_greater_equalSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_less_greaterSym) then
  begin
       Get;
  end
  else SynError(28);
end;

procedure TDelphiUnit._Term;
begin
  _Factor;
  while InSet(CurrentInputSymbol,35) do
  begin
    _MulOp;
    _Factor;
  end;
end;

procedure TDelphiUnit._AddOp;
begin
  if (CurrentInputSymbol=_plusSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_minusSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=ORSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=XORSym) then
  begin
       Get;
  end
  else SynError(29);
end;

procedure TDelphiUnit._Factor;
begin
  if (CurrentInputSymbol in [numberSym, floatSym, hexnumberSym]) then
  begin
       _Number;
  end
  else if (CurrentInputSymbol=stringSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=NILSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=NOTSym) then
  begin
       Get;
       _Factor;
  end
  else if (CurrentInputSymbol=_lbrackSym) then
  begin
       _SetConstructor;
  end
  else if (CurrentInputSymbol in [identSym, _atSym]) then
  begin
       _Designator;
  end
  else if (CurrentInputSymbol=_lparenSym) then
  begin
       Get;
       _Expression;
       Expect(_rparenSym);
  end
  else SynError(30);
end;

procedure TDelphiUnit._MulOp;
begin
  if (CurrentInputSymbol=_starSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=_slashSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=DIVSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=MODSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=ANDSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=SHLSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=SHRSym) then
  begin
       Get;
  end
  else SynError(31);
end;

procedure TDelphiUnit._Number;
begin
  if (CurrentInputSymbol=numberSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=floatSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=hexnumberSym) then
  begin
       Get;
  end
  else SynError(32);
end;

procedure TDelphiUnit._SetConstructor;
begin
  Expect(_lbrackSym);
  if InSet(CurrentInputSymbol,9) then
  begin
    _SetElement;
    while (CurrentInputSymbol=_commaSym) do
    begin
      Get;
      _SetElement;
    end;
  end;
  Expect(_rbrackSym);
end;

procedure TDelphiUnit._Designator;
var ns,name: String;
begin
  if (CurrentInputSymbol=_atSym) then
  begin
    Get;
  end;
  _GQualident(ns,name);
  while (CurrentInputSymbol in [_lparenSym, _lbrackSym, _uparrowSym]) do
  begin
    if (CurrentInputSymbol=_lbrackSym) then
    begin
         Get;
         _ExprList;
         Expect(_rbrackSym);
    end
    else if (CurrentInputSymbol=_lparenSym) then
    begin
         Get;
         _ExprList;
         Expect(_rparenSym);
    end
    else if (CurrentInputSymbol=_uparrowSym) then
    begin
         Get;
    end
    ;
  end;
end;

procedure TDelphiUnit._SetElement;
begin
  _Expression;
  while (CurrentInputSymbol=_point_pointSym) do
  begin
    Get;
    _Expression;
  end;
end;

procedure TDelphiUnit._ExprList;
begin
  _Expression;
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    _Expression;
  end;
end;

procedure TDelphiUnit._Generics(out val: String);
var pos: TSymbolRec; ns,n: String;
begin
                                 pos := NextSymbol^;
  Expect(_lessSym);
  if (CurrentInputSymbol=identSym) then
  begin
       _GQualident(ns,n);
  end
  else if (CurrentInputSymbol=strSym) then
  begin
       Get;
  end
  else SynError(33);
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    if (CurrentInputSymbol=identSym) then
    begin
         _GQualident(ns,n);
    end
    else if (CurrentInputSymbol=strSym) then
    begin
         Get;
    end
    else SynError(33);
  end;
  Expect(_greaterSym);
                                 pos.Len := CurSymbol^.Beg+CurSymbol^.Len-pos.Beg;
                                 val := XMLEscape(Scanner.getSymbolText(@pos));
                               
end;

procedure TDelphiUnit._GParm;
var ns,n: String;
begin
  if (CurrentInputSymbol=identSym) then
  begin
       _NopIdentList;
       if (CurrentInputSymbol=_colonSym) then
       begin
         Get;
         if (CurrentInputSymbol=CLASSSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=cntrSym) then
         begin
              Get;
         end
         else if (CurrentInputSymbol=identSym) then
         begin
              _GQualident(ns,n);
         end
         else SynError(34);
       end;
  end
  else if (CurrentInputSymbol=strSym) then
  begin
       Get;
  end
  else SynError(34);
end;

procedure TDelphiUnit._NopIdentList;
begin
  Expect(identSym);
  while (CurrentInputSymbol=_commaSym) do
  begin
    Get;
    Expect(identSym);
  end;
end;



function TDelphiUnit.TokenToString(n: Integer): String;
const TokenStrings: array[0.._NOSYMB] of String = ('EOF'
	,'ident'	,'number'	,'string'	,'float'	,'hexnumber'
	,'";"'	,'"STRING"'	,'"CONSTRUCTOR"'	,'"DESTRUCTOR"'	,'"INTERFACE"'
	,'"DISPINTERFACE"'	,'"RESOURCESTRING"'	,'"PROCEDURE"'	,'"IMPLEMENTATION"'	,'"DEPRECATED"'
	,'"PLATFORM"'	,'"LIBRARY"'	,'"ABSOLUTE"'	,'"STRICT"'	,'"PRIVATE"'
	,'"PROTECTED"'	,'"PUBLIC"'	,'"PUBLISHED"'	,'"CDECL"'	,'"REGISTER"'
	,'"DYNAMIC"'	,'"VIRTUAL"'	,'"EXPORT"'	,'"EXTERNAL"'	,'"NEAR"'
	,'"FAR"'	,'"FORWARD"'	,'"OVERRIDE"'	,'"OVERLOAD"'	,'"PASCAL"'
	,'"REINTRODUCE"'	,'"SAFECALL"'	,'"STDCALL"'	,'"VARARGS"'	,'"INLINE"'
	,'"ASSEMBLER"'	,'"STATIC"'	,'"MESSAGE"'	,'"FINAL"'	,'"ABSTRACT"'
	,'"HELPER"'	,'"SEALED"'	,'"INDEX"'	,'"DEFAULT"'	,'"READ"'
	,'"WRITE"'	,'"STORED"'	,'"IMPLEMENTS"'	,'"NODEFAULT"'	,'"READONLY"'
	,'"WRITEONLY"'	,'"DISPID"'	,'"UNIT"'	,'"USES"'	,'"CONST"'
	,'"VAR"'	,'"TYPE"'	,'":"'	,'"="'	,'"("'
	,'","'	,'")"'	,'"CLASS"'	,'"OBJECT"'	,'"["'
	,'"]"'	,'"TO"'	,'"^"'	,'"OF"'	,'".."'
	,'"PACKED"'	,'"RECORD"'	,'"FOR"'	,'"SET"'	,'"FILE"'
	,'"ARRAY"'	,'"CASE"'	,'"END"'	,'"FUNCTION"'	,'"OUT"'
	,'"IN"'	,'"."'	,'"PROPERTY"'	,'"+"'	,'"-"'
	,'"NIL"'	,'"NOT"'	,'"@"'	,'">"'	,'"<"'
	,'"<="'	,'">="'	,'"<>"'	,'"OR"'	,'"XOR"'
	,'"*"'	,'"/"'	,'"DIV"'	,'"MOD"'	,'"AND"'
	,'"SHL"'	,'"SHR"'  ,'not');
begin
  if n in [0.._NOSYMB] then
    Result := TokenStrings[n]
  else Result := '?';
end;

function TDelphiUnit.ErrorMessage(ErrorType, ErrorCode: Integer; const data: string): String;
begin
  case ErrorCode of
	1 : Result := 'invalid PortabilityDirective';
	2 : Result := 'this symbol not expected in InterfaceBody';
	3 : Result := 'invalid InterfaceDecl';
	4 : Result := 'invalid ConstantDecl';
	5 : Result := 'invalid VarDecl';
	6 : Result := 'invalid TypeDecl';
	7 : Result := 'invalid ExportedHeading';
	8 : Result := 'invalid TypeId';
	9 : Result := 'invalid Type';
	10 : Result := 'invalid ConstExprOrStructConst';
	11 : Result := 'invalid InterfaceType';
	12 : Result := 'invalid Directive';
	13 : Result := 'invalid ProcedureType';
	14 : Result := 'invalid StrucType';
	15 : Result := 'invalid SetType';
	16 : Result := 'invalid RecBody';
	17 : Result := 'invalid ArrayIndexType';
	18 : Result := 'invalid ClassSpec';
	19 : Result := 'invalid FieldDecl';
	20 : Result := 'invalid MethodHeading';
	21 : Result := 'invalid VariantSection';
	22 : Result := 'invalid FieldList';
	23 : Result := 'invalid ClassBody';
	24 : Result := 'invalid IMethodHeading';
	25 : Result := 'invalid ObjFieldDecl';
	26 : Result := 'invalid FormalParm';
	27 : Result := 'invalid PropertySpecifier';
	28 : Result := 'invalid RelOp';
	29 : Result := 'invalid AddOp';
	30 : Result := 'invalid Factor';
	31 : Result := 'invalid MulOp';
	32 : Result := 'invalid Number';
	33 : Result := 'invalid Generics';
	34 : Result := 'invalid GParm';


    else Result := inherited ErrorMessage(ErrorType, ErrorCode,data);
  end;
end;


procedure TDelphiUnit.ProcessPragmas;
begin
  case CurrentInputSymbol of
    DelphiPragmaSym:
	begin
                                         ProcessDelphiPragma(LexNames[1]); 
	end;
  end;

end;


function TDelphiUnit.Execute: Boolean;
begin
  Reinit;
  _DelphiUnit;
  Result := Successful;
end;


function TDelphiUnit.CreateScanner: TBaseScanner;
begin
  Result := TDelphiUnitScanner.Create(Self);
  if DelphiUnitST=nil then
  begin
    DelphiUnitST := TStartTable.Create;
    with DelphiUnitST do
    begin
	  FillRange(65, 90, 1);  States[95] := 1;  FillRange(48, 57, 28);  States[39] := 9;
	  States[35] := 10;  States[36] := 21;  States[59] := 23;  States[123] := 29;  States[40] := 46;
	  States[47] := 47;  States[58] := 31;  States[61] := 32;  States[44] := 33;  States[41] := 34;
	  States[91] := 35;  States[93] := 36;  States[94] := 37;  States[46] := 48;  States[43] := 39;
	  States[45] := 40;  States[64] := 41;  States[62] := 49;  States[60] := 50;  States[42] := 45;

    end;
    DelphiUnitLiterals := CreateLiterals(False,
	['STRING','CONSTRUCTOR','DESTRUCTOR','INTERFACE','DISPINTERFACE','RESOURCESTRING','PROCEDURE','IMPLEMENTATION'
		,'DEPRECATED','PLATFORM','LIBRARY','ABSOLUTE','STRICT','PRIVATE','PROTECTED','PUBLIC','PUBLISHED','CDECL','REGISTER'
		,'DYNAMIC','VIRTUAL','EXPORT','EXTERNAL','NEAR','FAR','FORWARD','OVERRIDE','OVERLOAD','PASCAL','REINTRODUCE','SAFECALL'
		,'STDCALL','VARARGS','INLINE','ASSEMBLER','STATIC','MESSAGE','FINAL','ABSTRACT','HELPER','SEALED','INDEX','DEFAULT'
		,'READ','WRITE','STORED','IMPLEMENTS','NODEFAULT','READONLY','WRITEONLY','DISPID','UNIT','USES','CONST','VAR','TYPE'
		,'CLASS','OBJECT','TO','OF','PACKED','RECORD','FOR','SET','FILE','ARRAY','CASE','END','FUNCTION','OUT','IN','PROPERTY'
		,'NIL','NOT','OR','XOR','DIV','MOD','AND','SHL','SHR'],
	[strSym,cntrSym,destrSym,intfSym,dintfSym,ressSym,procSym,implSym,-deprSym,-plfmSym,-libSym,-absSym,-STRICTSym,-PRIVATESym
		,-PROTECTEDSym,-PUBLICSym,-PUBLISHEDSym,-CDECLSym,-REGISTERSym,-DYNAMICSym,-VIRTUALSym,-EXPORTSym,-EXTERNALSym,-NEARSym,-FARSym
		,-FORWARDSym,-OVERRIDESym,-OVERLOADSym,-PASCALSym,-REINTRODUCESym,-SAFECALLSym,-STDCALLSym,-VARARGSSym,-INLINESym,-ASSEMBLERSym
		,-STATICSym,-MESSAGESym,-FINALSym,-ABSTRACTSym,-HELPERSym,-SEALEDSym,-INDEXSym,-DEFAULTSym,-READSym,-WRITESym,-STOREDSym,-IMPLEMENTSSym
		,-NODEFAULTSym,-READONLYSym,-WRITEONLYSym,-DISPIDSym,UNITSym,USESSym,CONSTSym,VARSym,TYPESym,CLASSSym,OBJECTSym,TOSym
		,OFSym,PACKEDSym,RECORDSym,FORSym,SETSym,FILESym,ARRAYSym,CASESym,ENDSym,FUNCTIONSym,OUTSym,INSym,PROPERTYSym,NILSym
		,NOTSym,ORSym,XORSym,DIVSym,MODSym,ANDSym,SHLSym,SHRSym]
     );
  end;
  with TDelphiUnitScanner(Result) do
  begin
    CaseInsensitive := True;  
    noSym := _NOSYMB;
    StartState := DelphiUnitST;
    Literals := DelphiUnitLiterals;
  end;
end;


constructor TDelphiUnit.Create(AOwner: TComponent);
begin
              
  PreProcessor := TDelphiCond.Create(Self);
  with PreProcessor do
  begin
   Version := 190;
   
//for Delphi2009  
//   Defines := PreProcessor.Defines +'UNICODE';
//   Version := 200;
  end;
  
  inherited;

  if Length(DelphiUnitSymSets)=0 then
  InitSymSets(DelphiUnitSymSets,[
    	{ 0} ressSym, procSym, CONSTSym, VARSym, TYPESym, FUNCTIONSym, -1,
	{ 1} _EOFSYMB, ressSym, procSym, CONSTSym, VARSym, TYPESym, FUNCTIONSym, -1,
	{ 2} _sclSym, deprSym, plfmSym, libSym, absSym, _equalSym, -1,
	{ 3} _sclSym, deprSym, plfmSym, libSym, _equalSym, -1,
	{ 4} CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, FINALSym, ABSTRACTSym, -1,
	{ 5} identSym, numberSym, stringSym, floatSym, hexnumberSym, strSym, procSym, TYPESym, _lparenSym, CLASSSym, _lbrackSym, _uparrowSym, PACKEDSym, RECORDSym, SETSym, FILESym, ARRAYSym, FUNCTIONSym, _plusSym, _minusSym, NILSym, NOTSym, _atSym, -1,
	{ 6} _sclSym, deprSym, plfmSym, libSym, -1,
	{ 7} _sclSym, ressSym, procSym, implSym, deprSym, plfmSym, libSym, CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, FINALSym, ABSTRACTSym, CONSTSym, VARSym, TYPESym, FUNCTIONSym, -1,
	{ 8} deprSym, plfmSym, libSym, CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, FINALSym, ABSTRACTSym, -1,
	{ 9} identSym, numberSym, stringSym, floatSym, hexnumberSym, _lparenSym, _lbrackSym, _plusSym, _minusSym, NILSym, NOTSym, _atSym, -1,
	{10} PACKEDSym, RECORDSym, SETSym, FILESym, ARRAYSym, -1,
	{11} identSym, numberSym, stringSym, floatSym, hexnumberSym, _sclSym, strSym, cntrSym, destrSym, intfSym, dintfSym, ressSym, procSym, implSym, deprSym, plfmSym, libSym, absSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, MESSAGESym, FINALSym, ABSTRACTSym, HELPERSym, SEALEDSym, INDEXSym, DEFAULTSym, READSym, WRITESym, STOREDSym, IMPLEMENTSSym, NODEFAULTSym, 
READONLYSym, WRITEONLYSym, DISPIDSym, UNITSym, USESSym, CONSTSym, VARSym, TYPESym, _colonSym, _equalSym, _lparenSym, _commaSym, _rparenSym, CLASSSym, OBJECTSym, _lbrackSym, TOSym, _uparrowSym, OFSym, _point_pointSym, PACKEDSym, RECORDSym, FORSym, SETSym, FILESym, ARRAYSym, CASESym, ENDSym, FUNCTIONSym, OUTSym, INSym, _pointSym, PROPERTYSym, _plusSym, _minusSym, NILSym, NOTSym, _atSym, _greaterSym, _lessSym, _less_equalSym, _greater_equalSym, _less_greaterSym, ORSym, XORSym, _starSym, _slashSym, DIVSym, MODSym, ANDSym, SHLSym, SHRSym, _NOSYMB, -1,
	{12} identSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, CLASSSym, _lbrackSym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{13} procSym, _lparenSym, _lbrackSym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{14} procSym, _lbrackSym, FUNCTIONSym, PROPERTYSym, -1,
	{15} identSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, CLASSSym, _lbrackSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{16} identSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, CLASSSym, _lbrackSym, CASESym, FUNCTIONSym, PROPERTYSym, -1,
	{17} STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, -1,
	{18} identSym, cntrSym, destrSym, procSym, CONSTSym, VARSym, TYPESym, CLASSSym, _lbrackSym, CASESym, FUNCTIONSym, PROPERTYSym, -1,
	{19} identSym, cntrSym, destrSym, procSym, VARSym, CLASSSym, _lbrackSym, FUNCTIONSym, PROPERTYSym, -1,
	{20} identSym, cntrSym, destrSym, procSym, VARSym, _lbrackSym, FUNCTIONSym, PROPERTYSym, -1,
	{21} identSym, cntrSym, destrSym, procSym, _lbrackSym, FUNCTIONSym, -1,
	{22} identSym, _sclSym, cntrSym, destrSym, procSym, deprSym, plfmSym, libSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _rparenSym, CLASSSym, _lbrackSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{23} identSym, _sclSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, _rparenSym, CLASSSym, _lbrackSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{24} identSym, _sclSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CDECLSym, REGISTERSym, DYNAMICSym, VIRTUALSym, EXPORTSym, EXTERNALSym, NEARSym, FARSym, FORWARDSym, OVERRIDESym, OVERLOADSym, PASCALSym, REINTRODUCESym, SAFECALLSym, STDCALLSym, VARARGSSym, INLINESym, ASSEMBLERSym, STATICSym, FINALSym, ABSTRACTSym, CONSTSym, VARSym, TYPESym, _lparenSym, CLASSSym, _lbrackSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{25} identSym, _sclSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, CLASSSym, _lbrackSym, CASESym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{26} INDEXSym, DEFAULTSym, READSym, WRITESym, STOREDSym, IMPLEMENTSSym, NODEFAULTSym, READONLYSym, WRITEONLYSym, DISPIDSym, -1,
	{27} identSym, cntrSym, destrSym, procSym, STRICTSym, PRIVATESym, PROTECTEDSym, PUBLICSym, PUBLISHEDSym, CONSTSym, VARSym, TYPESym, CLASSSym, _lbrackSym, FUNCTIONSym, PROPERTYSym, -1,
	{28} identSym, cntrSym, destrSym, procSym, CONSTSym, VARSym, TYPESym, CLASSSym, _lbrackSym, FUNCTIONSym, PROPERTYSym, -1,
	{29} _sclSym, procSym, _lbrackSym, ENDSym, FUNCTIONSym, PROPERTYSym, -1,
	{30} identSym, CONSTSym, VARSym, OUTSym, INSym, -1,
	{31} CONSTSym, VARSym, OUTSym, INSym, -1,
	{32} INDEXSym, DEFAULTSym, STOREDSym, DISPIDSym, -1,
	{33} _greaterSym, _lessSym, _less_equalSym, _greater_equalSym, _less_greaterSym, -1,
	{34} _plusSym, _minusSym, ORSym, XORSym, -1,
	{35} _starSym, _slashSym, DIVSym, MODSym, ANDSym, SHLSym, SHRSym
  ]); 
  SymSets := DelphiUnitSymSets;
  
end;

end.

